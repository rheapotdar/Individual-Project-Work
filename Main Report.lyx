#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\date{}
\usepackage{fancyhdr}
\fancyhead{}
\renewcommand{\headrulewidth}{0pt}% Remove header rule
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{} 

\lstset{language=matlab,tabsize=2,showstringspaces=false,showspaces=false,breaklines=true}

\usepackage{amssymb,pepa, setspace}

\hyphenpenalty 100000
\exhyphenpenalty 100000
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\boxbgcolor #d3d3d3
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 4cm
\topmargin 3cm
\rightmargin 4cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
LARGE Imperial College London}
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Department of Computing}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large MEng Final Report}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Title
\end_layout

\begin_layout Plain Layout


\backslash
rule[2.8ex]{1
\backslash
columnwidth}{1pt} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{spacing}{1.75} 
\backslash
vspace{-0.7cm} { 
\backslash
huge 
\backslash
bfseries Automatic construction of product-form solutions in stochastic
 networks }
\backslash

\backslash
[0.1cm]
\backslash
end{spacing}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
rule[10.5ex]{1
\backslash
columnwidth}{1pt} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Author and supervisor
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft} 
\backslash
large
\end_layout

\begin_layout Plain Layout


\backslash
emph{Author:}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Rhea Potdar 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
textsc{} 
\backslash

\backslash
 
\backslash
textsc{} 
\backslash

\backslash
 
\backslash
textsc{}
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushright} 
\backslash
large
\end_layout

\begin_layout Plain Layout


\backslash
emph{Supervisor:} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Prof.
 Peter Harrison 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
textsc{} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
emph{Second Marker:} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Dr.
 Giuliano Casale
\end_layout

\begin_layout Plain Layout


\backslash
end{flushright}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
vspace{2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
cross}{
\backslash
ding{55}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
tickbullets}{
\backslash
def
\backslash
labelitemi{
\backslash
ding{51}}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
crossbullets}{
\backslash
def
\backslash
labelitemi{
\backslash
ding{55}}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
normalbullets}{
\backslash
def
\backslash
labelitemi{
\backslash
(
\backslash
bullet
\backslash
)}} 
\backslash
normalbullets
\end_layout

\begin_layout Plain Layout


\backslash
definecolor{grey}{RGB}{240,240,240} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman} % Roman numerals 
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
Abstract
\end_layout

\begin_layout Standard
The growing complexity of modern systems has escalated the need for performance
 metrics.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
for capacity planning.
 (another phrase)
\end_layout

\end_inset

 Stochastic models such as queuing networks and stochastic Petri nets have
 been used to model these systems so that their performance measures can
 be evaluated analytically.
 Product-form solutions are equilibrium state probabilities in networks
 of stochastic nodes (e.g.
 queues) in the form of a product of terms relating to each node separately.
 One can derive various performance metrics from these product form solutions,
 thus there is considerable effort dedicated to finding them in various
 stochastic models.
\end_layout

\begin_layout Standard
An established theorem, the Reversed Compound Agent Theorem (RCAT), derives
 mechanically the product-form solutions for stochastic models defined as
 a composition of two or more smaller stochastic models, under some conditions.
 Its use of the divide-and-conquer approach solves problems of state space
 explosion and computationally complexity, which standard methods face while
 finding product-forms for large and complex networks.
\end_layout

\begin_layout Standard
This report presents a working implementation of RCAT in MATLAB and its
 extension Multiple Agent RCAT which can be applied to a wide variety of
 queuing networks with multiple components.
 It also provides the first working implementation of RCAT applied to stochastic
 Petri nets thus expanding its utility to analyse models composed of both
 Petri nets and queuing networks.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
Acknowledgements
\end_layout

\begin_layout Standard
I would like to thank my supervisor, Prof.
 Peter Harrison, for his tremendous support, motivation and invaluable advice
 throughout this project, and also my family and friends for their encouragement
 and blessings.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \enskip{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{tocdepth}{2}
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
In the recent years, there has been an increase in the complexity of computer
 systems making performance models essential for understanding the behaviour
 of these systems.
 These performance models help determine performance measures of computer
 systems such as utilisation, throughput and help ensure that the systems
 can manage varying workload, that the utilisation of resources is fair
 and the list goes on.
 To analyse these computer systems, they are described abstractly using
 stochastic models which are then used to evaluate various performance measures
 of the systems.
\end_layout

\begin_layout Standard
Queuing networks (models with underlying Markov Processes) and stochastic
 Petri nets are two common stochastic models which are known to accurately
 describe computer systems and can be evaluated analytically.
 However due to the increase in complexity, the number of components of
 systems has increased, leading to a large state space and thus very high
 computational costs while analysing stochastic models.
 To improve the efficiency of this process, much effort has been devoted
 to finding the 
\emph on
product-form
\emph default
 solutions for the steady state probabilities of systems.
 The product-form solutions, when it exists, can be derived for the joint
 steady state probabilities of interacting Markov processes by finding the
 the reversed process of the interaction.
 Analytically, this involves solving Kolmogorov (balance) equations 
\begin_inset CommandInset citation
LatexCommand cite
key "PerformanceModellingHarrisonBook"

\end_inset

 which can quickly cause state space explosion making the process computationall
y prohibitive for systems composed of many components.
\end_layout

\begin_layout Standard
To ease the computational difficulty, the Reversed Compound Agent Theorem
 (RCAT) 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

 has been proved, which provides a method for finding product-form solutions
 using the divide-and-conquer approach.
 RCAT derives mechanically the product form solutions for steady state probabili
ties of stochastic models defined as a cooperation (or synchronisation)
 of two or more smaller stochastic models under some conditions.
 This approach for deriving the steady state probabilities of Markov processes
 does not require Kolmogorov equations to be solved.
 RCAT uses PEPA (Performance Evaluation Process Algebra), a Markovian Process
 Algebra formalism, which has an appropriate recursive structure for hierarchica
l analysis done by RCAT.
 But this does not limit the application of RCAT to systems specified by
 Markovian Process Algebra.
 It can also be applied to derive product-forms in Stochastic Petri Nets
 which are specified diagrammatically and are more difficult to trace.
\end_layout

\begin_layout Standard
The RCAT theorem is proven to automatically derive product form solutions
 of G-networks 
\begin_inset CommandInset citation
LatexCommand cite
key "GelenbeGNetworks"

\end_inset

 with negative customers, with ease comparable to deriving product form
 solutions of simpler Jackson queuing networks.
 This shows its compositional utility in validating product form solutions
 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

.
 It can also be used for finding new product form solutions of networks
 with no known product form - such as blocking networks.
\end_layout

\begin_layout Section
Contributions
\end_layout

\begin_layout Standard
The main contributions of this project are summarised below:
\end_layout

\begin_layout Itemize
Automatic construction of `rate equations' used to derive product form solutions
 by implementing the RCAT and the Multiple Agent RCAT 
\begin_inset CommandInset citation
LatexCommand cite
key "RCAT2009Paper"

\end_inset

, allowing construction of product forms of queuing models composed of more
 than two processes.
\end_layout

\begin_layout Itemize
Automatic construction of `rate equations' used to derive product form solutions
 of Stochastic Petri Nets (SPNs).
\end_layout

\begin_layout Itemize
A parser which translates a pure PEPA description as text input into a format
 required in the RCAT implementation.
 It provides a validator which checks to see whether the textual input actually
 resembles a meaningful PEPA process.
\end_layout

\begin_layout Itemize
A formalism for specifying a hierarchically defined subset of SPNs as programmab
le input and a parser for translating that input into a format required
 by the implementation.
\end_layout

\begin_layout Itemize
Ensuring the accuracy of the results generated by running the implementation
 over a varied class of queuing models and Petri nets and ensuring the implement
ation has ease of use by providing a clean and simple API.
\end_layout

\begin_layout Section
Report Structure
\end_layout

\begin_layout Standard
The remainder of the report is organised as follows:
\end_layout

\begin_layout Itemize

\series bold
Chapter 2 
\series default
provides a brief introduction to Markov Chains, Markov processes, Reversed
 Processes and Queuing networks.
 It then covers the theory necessary to comprehend the RCAT such as PEPA
 and proceeds to explain RCAT and (E)RCAT, and concludes with a background
 to Stochastic Petri Nets and product form Building blocks.
\end_layout

\begin_layout Itemize

\series bold
Chapter 3 
\series default
describes the design choices and the implementation details of automating
 RCAT, starting from the parser - PEPA to MATLAB - and concluding with generatin
g a system of rate equations and showing how to use them to generate product
 form solutions.
\end_layout

\begin_layout Itemize

\series bold
Chapter 4 
\series default
describes the implementation details of extending RCAT to MARCAT and the
 implementation details of implementing RCAT for SPNs.
 It details parsing choices, a new formalism for the SPNs, showing how product
 form solutions are generated for SPNs and concludes with a design analysis
 for implementing RCAT for chains of interactions between queues.
\end_layout

\begin_layout Itemize

\series bold
Chapter 5 
\series default
evaluates the project by running the implementation against a variety of
 queuing models and Petri nets and reviews the limitations and overall contribut
ions of the project.
\end_layout

\begin_layout Itemize

\series bold
Chapter 6 
\series default
summarises the contributions of this project as a formal conclusion to the
 report and includes suggestions for extending the project in the future.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Background
\end_layout

\begin_layout Standard
In this chapter, we will explore the theory required for the automatic generatio
n of product forms by implementing the RCAT.
 We commence this chapter by describing the relavent theory behind Markov
 Chains, Markov Processes and Reversed Process as shown in 
\begin_inset CommandInset citation
LatexCommand cite
key "LectureNotes,PerformanceModellingHarrisonBook,MarkovChainsQueuesStewartBook"

\end_inset

.
\end_layout

\begin_layout Section
Markov Chains
\end_layout

\begin_layout Standard
In order to comprehend Markov Chains and Markov Processes, one must be familiar
 with stochastic processes.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.1.1
\end_layout

\begin_layout Plain Layout
A 
\series bold
stochastic process S
\series default
 is defined as a family of random variables 
\begin_inset Formula $\{X_{t}\in\Omega\text{ | }t\text{ }\in\text{ }T\}$
\end_inset

 , which take values from some sample space 
\begin_inset Formula $\Omega$
\end_inset

 and are indexed by values from some parameter space 
\begin_inset Formula $T$
\end_inset

.
 
\begin_inset Formula $\Omega$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

 may be either discrete or continuous.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
Markov chain
\series default
 is a stochastic process that has the 
\emph on
Markov Property
\emph default
 with a countable sample space (or state space) 
\begin_inset Formula $\Omega$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.1.2
\end_layout

\begin_layout Plain Layout
The 
\series bold
Markov Property (MP)
\series default
 states that
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
P(X_{t+s}=j\mbox{ | }X_{u},\mbox{ }u\text{≤}t) & = & P(X_{t+s}=j\mbox{ | }X_{t})\label{eq:Markov Property}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Plain Layout
This states that the conditional probability distribution of future states
 depends only on the current state and not the events that preceded it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Markov chains can also be denoted as labelled transition systems, undergoing
 transitions with different rates between finite number of possible states.
\end_layout

\begin_layout Subsection
Discrete Time Markov Chains
\end_layout

\begin_layout Standard
Discrete Time Markov Chains (DTMC) are Markov chains with a parameter space
 T consisting of discrete times 
\begin_inset Formula $\{t_{0},t_{1},...\}$
\end_inset

.
 We are interested in the behaviour of a DTMC at equilibrium and the following
 results are used in defining it.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.1.3
\end_layout

\begin_layout Plain Layout
The m-step transition probabilities of a Markov chain defined as
\end_layout

\begin_layout Plain Layout

\family sans
\begin_inset Formula 
\begin{eqnarray*}
p_{ij}^{(m)} & = & P(X_{n+m}=j\mbox{ }|\mbox{ }X_{n}=i),\mbox{ }(m\geq1)\\
 & = & (P^{m})_{ij}
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since we are interested in the long term behaviour of DTMC, we can use its
 m-step transition probabilities to calculate the probabilistic behaviour
 of DTMC over any finite period of time.
 Thus the probability of a DTMC being in an arbitrary state j at equilibrium
 is defined as:
\end_layout

\begin_layout Standard

\family sans
\begin_inset Formula 
\begin{eqnarray*}
\pi_{j} & = & lim_{n\to\infty}P(X_{n}=j\mbox{ |}X_{0}=i)\\
 & = & lim_{n\to\infty}(P^{n})_{ij}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.1.4
\end_layout

\begin_layout Plain Layout
If C is a subset of states, then it is called 
\series bold
closed
\series default
 if j 
\begin_inset Formula $\notin$
\end_inset

 C implies j cannot be reached from any i 
\begin_inset Formula $\in$
\end_inset

 C .
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\nexists$
\end_inset

 a proper subset 
\begin_inset Formula $C\subset\Omega$
\end_inset

 which is closed, then the Markov chain is called 
\emph on
irreducible
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.1.6
\end_layout

\begin_layout Plain Layout
The state j is 
\series bold
periodic
\series default
 with period 
\begin_inset Formula $m>1$
\end_inset

 if 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
p_{ii}^{(k)}=0 & , & k\neq rm\mbox{ for any }r\geq1
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
and 
\begin_inset Formula 
\begin{eqnarray*}
P(X_{n+rm}=j\mbox{ for some }r\geq1\mbox{ | }X_{n}=j) & = & 1
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otherwise the state is 
\emph on
aperiodic
\emph default
, or has period 1.
 An aperiodic DTMC is one in which all states are aperiodic.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.1.5
\end_layout

\begin_layout Plain Layout
Let 
\begin_inset Formula $m_{j}$
\end_inset

 is the mean interval between successive visits to state j.
 If 
\begin_inset Formula $m_{j}<\infty$
\end_inset

 and 
\begin_inset Formula $\pi_{j}=1/m_{j}$
\end_inset

, then 
\begin_inset Formula $\pi_{j}>0$
\end_inset

 and state 
\begin_inset Formula $j$
\end_inset

 is recurrent non-null or 
\series bold
positive recurrent
\series default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A positive recurrent DTMC is a DTMC in which all states are positive recurrent.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Proposition 2.1.1
\end_layout

\begin_layout Plain Layout
If 
\begin_inset Formula $\mbox{\{}X_{n}\mbox{ | }n=0,1,...\mbox{\}}$
\end_inset

 is an irreducible, aperiodic Markov chain, then the limiting probabilities
 
\begin_inset Formula $\mbox{\{}\pi_{j}|j=0,1,...\mbox{\}}$
\end_inset

 exist and 
\begin_inset Formula $\pi_{j}=1/m_{j}$
\end_inset

 where 
\begin_inset Formula $m_{j}$
\end_inset

 is the mean interval between successive visits to state j.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the limiting probabilities 
\begin_inset Formula $\mbox{\{}\mbox{\pi_{j}}|j=0,1,...\mbox{\}}$
\end_inset

 do exist, they form the steady state probability distribution (SSPD) of
 a DTMC.
 This is formally defined by the following Theorem 2.1.1.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Theorem 2.1.1
\end_layout

\begin_layout Plain Layout
An irreducible, aperiodic Markov Chain, 
\begin_inset Formula $X$
\end_inset

, with state space 
\begin_inset Formula $S$
\end_inset

 and one-step transition probability matrix 
\begin_inset Formula $P=(p_{ij}\mbox{ | }i,j\in S)$
\end_inset

 , is positive recurrent if and only if the system of equations
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\pi_{j} & = & \sum_{i\in S}\pi_{i}p_{ij}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
and (normalisation):
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\sum_{i\in S}\pi_{i} & = & 1
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
has a solution.
 If it exists, the solution is unique and is the SSPD of X.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Markov Processes
\end_layout

\begin_layout Standard
A Markov process(MP) is a stochastic process, which has a 
\emph on
continuous
\emph default
 parameter space T, discrete sample space 
\begin_inset Formula $\Omega$
\end_inset

 and the 
\emph on
Markov property
\emph default
 (refer equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Markov Property"

\end_inset

).
 They can also be defined as Markov chains with continuous time parameters.
 
\end_layout

\begin_layout Standard
A Markov process is 
\emph on
time homogenous
\emph default
 if the transition probability function of MP, 
\begin_inset Formula $p_{ij}(s)=P(X_{t+s}=j\mbox{ | }X_{t}=i)$
\end_inset

 , is independent of 
\begin_inset Formula $t$
\end_inset

, or equivalently 
\begin_inset Formula $p_{ij}(s)=P(X_{s}=j\mbox{ | }X_{0}=i)$
\end_inset

.
 Markov Property and time homogeneity imply the 
\emph on
memoryless property
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.2.1
\end_layout

\begin_layout Plain Layout
The 
\series bold
memoryless property
\series default
 of a Markov process states that if at time 
\begin_inset Formula $t$
\end_inset

 the process is in state 
\begin_inset Formula $j$
\end_inset

, the time remaining in state 
\begin_inset Formula $j$
\end_inset

 is independent of the time already spent in state 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using time homogeneity, the generators 
\begin_inset Formula $q_{ij}$
\end_inset

 of a Markov Process can be uniquely determined by the products:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
q_{ij} & = & \mu_{i}p_{ij}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\mu_{i}$
\end_inset

 is the rate out of state 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $p_{ij}$
\end_inset

 is the probability of selecting state 
\begin_inset Formula $j$
\end_inset

 next.
 
\begin_inset Formula $q_{ij}$
\end_inset

 is also the instantaneous transition rate from state 
\begin_inset Formula $i$
\end_inset

 to state 
\begin_inset Formula $j$
\end_inset

, 
\begin_inset Formula $i\neq j$
\end_inset

.
 They also form 
\series bold
\emph on
Q
\series default
\emph default
, generator matrix of the Markov Process, in which all rows sum to zero
 by setting 
\begin_inset Formula $q_{ii}=−\mu_{i}$
\end_inset

.
 So 
\begin_inset Formula $Q=(q_{ij})$
\end_inset

 .
\end_layout

\begin_layout Subsection
SSPD of the Markov Process
\end_layout

\begin_layout Standard
If a Markov Process is positive recurrent, the limits 
\begin_inset Formula $\pi_{j}$
\end_inset

 exist, then 
\begin_inset Formula $\pi_{j}>0,\sum_{j\in S}\pi_{j}=1$
\end_inset

 and {
\begin_inset Formula $\pi_{j}\mbox{ | }j\in S$
\end_inset

} constitute the SSPD or Steady State Probability Distribution of the Markov
 Process.
 This is formally defined by Theorem 2.2.1.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Theorem 2.2.1 
\end_layout

\begin_layout Plain Layout
An irreducible Markov Process 
\begin_inset Formula $X$
\end_inset

 with state space 
\begin_inset Formula $S$
\end_inset

 and generator matrix 
\begin_inset Formula $Q=(q_{ij})\mbox{ }(i,j\in S)$
\end_inset

 is positive recurrent if and only if
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\forall j\in S$
\end_inset

 , Balance equations:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\sum_{i\in S}\pi_{i}q_{ij} & = & 0\mbox{ }
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
and Normalising equation:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
\sum_{i\in S}\pi_{i} & = & 1\label{eq:Normalising_Eq_MP}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Plain Layout
have a solution.
 This solution is unique and is the SSPD.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
From Theorem 2.2.1, we can rewrite the balance equations as 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\sum_{j\neq i}\pi_{i}q_{ij} & = & \sum_{j\neq i}\pi_{j}q_{ji}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Following gives the justification of the balance equations:
\end_layout

\begin_layout Standard
In equilibrium, 
\begin_inset Formula $\pi_{i}$
\end_inset

 is the proportion of time that the process spends in state 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $q_{ij}$
\end_inset

 is the rate at which the process goes from state 
\begin_inset Formula $i\to j\mbox{ }(j\neq i)$
\end_inset

.
 Thus, in unit time, the expected number of transitions from state 
\begin_inset Formula $i$
\end_inset

 to state 
\begin_inset Formula $j$
\end_inset

 is 
\begin_inset Formula $\pi_{i}q_{ij}$
\end_inset

 .
 This quantity is called the 
\emph on
probability flux
\emph default
 from state 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

.
 So we can infer that the left-hand side of the balance equation for state
 
\begin_inset Formula $i$
\end_inset

 is the total flux out of state 
\begin_inset Formula $i$
\end_inset

 to any other state.
 Similarly, the right-hand side is the total flux into state 
\begin_inset Formula $i$
\end_inset

 from any other state.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\implies\forall j$
\end_inset

 , the fluxes balance:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\sum_{i\neq j}flux(i\to j) & = & \sum_{i\neq j}flux(j\to i)\label{eq:BalanceEquations}
\end{eqnarray}

\end_inset

 
\end_layout

\begin_layout Subsection
Example - Poisson Process
\end_layout

\begin_layout Standard
The Poisson process is a renewal process with renewal period (inter-arrival
 time) having cumulative distribution function 
\begin_inset Formula $F$
\end_inset

 and probability density function (pdf) 
\begin_inset Formula $f$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
F(x) & = & P(X\leq x)=1-e^{-\lambda x}\\
f(x) & = & F'(x)=\lambda e^{-\lambda x}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\lambda$
\end_inset

 is the rate of the Poisson process.
 Since its an example of a Markov process its probability of arrival in
 period 
\begin_inset Formula $(t,t+h)$
\end_inset

 is independent of the process history before 
\begin_inset Formula $t$
\end_inset

.
 So by memoryless property:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
P(\mbox{arrival in }(t,t+h)) & = & 1-e^{-\lambda h}\\
 & = & \lambda h+o(h)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
From the above result we get the instantaneous transition rates which can
 be then used to find the SSPD for the process.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
q_{ij} & = & \begin{cases}
\lambda & \mbox{if }j=i+1\\
0 & \mbox{if}j\neq i,i+1\\
 & \mbox{not defined if }j=i
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsection
Birth-Death Processes
\end_layout

\begin_layout Standard
Birth-death process is a special case of Markov Process with state space
 
\begin_inset Formula $\{0,1,...\}$
\end_inset

 in which a one-step transition can only change the current state by one
 unit, so if 
\begin_inset Formula $i\to j$
\end_inset

 then 
\begin_inset Formula $|i-j|=1$
\end_inset

.
 This process thus has only non-zero transition probabilities - 
\begin_inset Formula $a_{i,i+1}$
\end_inset

 and 
\begin_inset Formula $a_{i+1,i}\mbox{ }(i\geq0)$
\end_inset

 , representing 
\emph on
births
\emph default
 and 
\emph on
deaths
\emph default
 respectively.
 This ensures the population need not become extinct when state 0 is reached
 which is useful while considering queues, where arrivals can join an empty
 queue, represented by state 0.
 The SSPD of this process is discussed later taking M/M/1 queue as an example.
\end_layout

\begin_layout Section
Single Server Queue (SSQ)
\end_layout

\begin_layout Standard
The Single Server Queue Model 
\begin_inset CommandInset citation
LatexCommand cite
key "PerformanceModellingHarrisonBook"

\end_inset

 - SSQ - is a birth-death process that consists of 
\end_layout

\begin_layout Itemize
a Poisson arrival process with a rate of 
\begin_inset Formula $\lambda$
\end_inset


\end_layout

\begin_layout Itemize
a queue which the arriving tasks join
\end_layout

\begin_layout Itemize
a server with a FIFO queuing discipline and exponentially distributed service
 times with parameter 
\begin_inset Formula $\mu$
\end_inset

 
\end_layout

\begin_layout Standard
The M/M/1 queue is an example of the SSQ model.
\end_layout

\begin_layout Subsection
Kendall's Notation
\end_layout

\begin_layout Standard
Queues are classified according to Kendall's notation 
\begin_inset CommandInset citation
LatexCommand cite
key "PerformanceModellingHarrisonBook,LectureNotes"

\end_inset

, which defines the class 
\emph on
A/S/m/K/N/D 
\emph default
as:
\end_layout

\begin_layout Itemize

\emph on
A
\emph default
 describes the nature of the arrival process.
 For example if the process is Poisson, then 
\begin_inset Formula $A=M$
\end_inset

 for Markovian.
\end_layout

\begin_layout Itemize

\emph on
S
\emph default
 describes the service time distribution.
 
\begin_inset Formula $S=M$
\end_inset

 for a Markovian (exponential) service time distribution, while 
\begin_inset Formula $S=G$
\end_inset

 stands for a general or non-Markovian service time distribution.
\end_layout

\begin_layout Itemize

\emph on
m
\emph default
 denotes the number of servers available to give service to customers in
 the queue.
 
\begin_inset Formula $m=1$
\end_inset

 refers to a single server, while 
\begin_inset Formula $m=m$
\end_inset

 shows a parallel server.
\end_layout

\begin_layout Itemize

\emph on
K
\emph default
 denotes the capacity of the system or the maximum number of customers allowed
 in the system.
\end_layout

\begin_layout Itemize

\emph on
N 
\emph default
denotes the size of the population from which the customers come.
\end_layout

\begin_layout Itemize

\emph on
D
\emph default
 denotes the queuing discipline or priority order in which customers are
 served in the queue.
\end_layout

\begin_layout Standard
In this paper, the concise form - 
\series bold
\emph on
A/S/m
\series default
\emph default
 - is used and default values 
\begin_inset Formula $K=\infty,\mbox{ }N=\infty,\mbox{ }D=FIFO$
\end_inset

 are assumed.
\end_layout

\begin_layout Subsection
M/M/1 Queue
\end_layout

\begin_layout Standard
The M/M/1 queue 
\begin_inset CommandInset citation
LatexCommand cite
key "PerformanceModellingHarrisonBook"

\end_inset

 is an example of the SSQ model with a Poisson arrival process rate 
\begin_inset Formula $\lambda$
\end_inset

, Markovian service time distribution rate 
\begin_inset Formula $\mu$
\end_inset

, unlimited server capacity and infinite calling population.
 The rates 
\begin_inset Formula $\lambda\mbox{ , }\mu$
\end_inset

 are general functions of the queue length; so when the queue length is
 n, we write them as 
\begin_inset Formula $\lambda(n)\mbox{ ,}\mu(n)$
\end_inset

.
 Considering the M/M/1 queue in equilibrium, in the steady state, we can
 write down the probability flux balance equations passing in and out of
 the states shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:M/M/1-Queue-state"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/MM1_Queue_state_transition.svg
	scale 55

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
M/M/1 Queue state diagram
\begin_inset CommandInset label
LatexCommand label
name "fig:M/M/1-Queue-state"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is only one outgoing arc and one incoming arc.
 The balance equations are therefore, 
\end_layout

\begin_layout Standard
Outward flux (all from state 
\begin_inset Formula $i$
\end_inset

): 
\begin_inset Formula $\pi_{i}\lambda(i)$
\end_inset

 , 
\begin_inset Formula $\forall i\geq0\mbox{, }i\in S$
\end_inset

 
\end_layout

\begin_layout Standard
Inward flux (all from state 
\begin_inset Formula $i+1$
\end_inset

): 
\begin_inset Formula $\pi_{i+1}\mu(i+1)$
\end_inset

 , 
\begin_inset Formula $\forall i\geq0\mbox{, }i\in S$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\implies$
\end_inset

 balance equations (using equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:BalanceEquations"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\pi_{i}\lambda(i) & = & \pi_{i+1}\mu(i+1)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
So,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\pi_{i+1} & = & \frac{\lambda(i)}{\mu(i+1)}\pi_{i}\\
 & = & [\prod_{j=0}^{i}\rho(j)]\mbox{ }\pi_{0}\\
\mbox{where }\rho(j) & = & \frac{\lambda(i)}{\mu(i+1)}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
The Normalising equation (refer equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Normalising_Eq_MP"

\end_inset

) implies that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\pi_{0}(1+\sum_{i=0}^{\infty}\prod_{j=0}^{i}\rho(j)) & = & 1
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Solving the equations we get the steady state probability 
\begin_inset Formula $\pi_{i}$
\end_inset

 for any state 
\begin_inset Formula $i\geq0$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\pi_{i} & = & \frac{\prod_{j=0}^{i-1}\rho(j)}{\sum_{k=0}^{\infty}\prod_{n=0}^{k-1}\rho(n)}\mbox{ }(i\geq0)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
In a classical M/M/1 queue, the arrival and service rates, 
\begin_inset Formula $\lambda\mbox{ and }\mu$
\end_inset

 respectively, are constant.
 So 
\begin_inset Formula $\forall n\in S$
\end_inset

 , 
\begin_inset Formula $\lambda(n)=\lambda\mbox{ , }\mu(n)=\mu\mbox{ , }\rho(n)=\rho=\frac{\lambda}{\mu}$
\end_inset

 .
 This implies,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\pi_{i} & = & \frac{\prod_{j=0}^{i-1}\rho^{j}}{\sum_{k=0}^{\infty}\prod_{n=0}^{k-1}\rho^{n}}\nonumber \\
 & = & (1-\rho)\rho^{i}\mbox{ }(i\geq0)\label{eq:SSPD_of_MM1Q}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
The derived result (equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:SSPD_of_MM1Q"

\end_inset

) is the simplified version of the SSPD of M/M/1 queues.
\end_layout

\begin_layout Standard
Since this (equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:SSPD_of_MM1Q"

\end_inset

) is a geometric mass probability function, it is easy to deduce the mean
 length of the queue 
\begin_inset Formula $(L)$
\end_inset

 and utilisation of the server 
\begin_inset Formula $(U)$
\end_inset

 in equilibrium.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
L & = & \frac{\rho}{(1-\rho)}\\
U & = & 1-\pi_{0}=\rho
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
It can be noted here that, the mean arrival rate 
\begin_inset Formula $(\lambda)$
\end_inset

 is equal to the mean departure rate 
\begin_inset Formula $(U\mu)$
\end_inset

 in steady state, as required.
\end_layout

\begin_layout Standard
The above analysis and argument applies to any system in equilibrium.
\end_layout

\begin_layout Section
Reversed Processes
\end_layout

\begin_layout Standard
A 
\emph on
reversed process
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "BradleyRP&RCAT,HarrisonPaperTBTinMAP2003,PerformanceModellingHarrisonBook,LectureNotes"

\end_inset

 of a stationary Markov process is a stochastically identical process (to
 the original MP) with the same state space but in to which the direction
 of time has been reversed.
 Knowledge of the reversed process allows us solve balance equations of
 a Markov process in equilibrium and therefore obtain product-form stationary
 distributions of complex processes such queuing network models.
 Thus comprehension of reversed processes helps in applying the RCAT theorem
 (discussed in Section 2.6.2).
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.4.1
\end_layout

\begin_layout Plain Layout
A stochastic process 
\begin_inset Formula $\{X_{t}\mbox{ | }-\infty<t<\infty\}$
\end_inset

 is 
\series bold
stationary 
\series default
if 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
(X_{t_{1}}\mbox{, }X_{t_{2}},\mbox{... , }X_{t_{n}}) & \mbox{\emph{ }and} & (X_{t_{1}+\tau}\mbox{, }X_{t_{2}+\tau},\mbox{... , }X_{t_{n}+\tau})
\end{eqnarray*}

\end_inset

and have the same probability distribution for all times 
\begin_inset Formula $t_{1}\mbox{ , }t_{2}\mbox{ , .... , }t_{n}\mbox{ and }\tau$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.4.2
\end_layout

\begin_layout Plain Layout
A stochastic process 
\begin_inset Formula $\{X_{t}\mbox{ | }-\infty<t<\infty\}$
\end_inset

 is 
\series bold
reversible 
\series default
if 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
(X_{t_{1}}\mbox{, }X_{t_{2}},\mbox{... , }X_{t_{n}}) & \mbox{\emph{ }and} & (X_{\tau-t_{1}}\mbox{, }X_{\tau-t_{2}},\mbox{... , }X_{\tau-t_{n}})
\end{eqnarray*}

\end_inset

and have the same probability distribution for all times 
\begin_inset Formula $t_{1}\mbox{ , }t_{2}\mbox{ , .... , }t_{n}\mbox{ and }\tau$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Definitions 4.1 and 4.2 relate a stationary Markov process to its reversed
 process.
 Thus the reversed process of a Markov process 
\begin_inset Formula $\{X_{t}\}$
\end_inset

 will be the stationary process 
\begin_inset Formula $\{X_{\tau-t}\}$
\end_inset

 for any real number 
\begin_inset Formula $\tau$
\end_inset

.
 We can also define a reversed process in terms of balance conditions of
 a stationary Markov process as in the following Proposition 2.4.1.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Proposition 2.4.1
\end_layout

\begin_layout Plain Layout
A stationary Markov process 
\begin_inset Formula $\{X_{t}\}$
\end_inset

 with a generator matrix 
\begin_inset Formula $Q=(q_{ij})$
\end_inset

 is reversible if and only if there exists a collection of positive real
 numbers 
\begin_inset Formula $\{\pi_{k}\mbox{ | }k\in S\}$
\end_inset

 satisfying the detailed balance equations:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\pi_{i}q_{ij}=\pi_{j}q_{ji} &  & (\forall i,j\in S,i\neq j)
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of a reversible process is the M/M/1 queue.
 An M/M/1 queue is a birth-death process and thus its transition graph is
 linear - a tree with no branches.
 So, the probability flux in and out of states balances as derived at equation
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:BalanceEquations"

\end_inset

.
 Thus by Proposition 2.4.1 the M/M/1 queue is reversible.
\end_layout

\begin_layout Standard
The departure process of an M/M/1 queue is also identical to the arrival
 process in the reversed queue.
 To prove this claim let process 
\begin_inset Formula $N_{t}$
\end_inset

 denote the number of customers in the queue at time t.
 An arrival corresponds to the instants 
\begin_inset Formula $N_{t}$
\end_inset

 jumps up by one and defines a Poisson arrival process.
 Due to reversibility, instants at which 
\begin_inset Formula $N_{-t}$
\end_inset

 jumps upwards by one also define a reversible process.
 But arrivals in 
\begin_inset Formula $N_{-t}$
\end_inset

 become departures in 
\begin_inset Formula $N_{t}$
\end_inset

 thus proving that the departure process forms an identical Poisson process.
 
\end_layout

\begin_layout Standard
Proposition 2.4.1 would be useful to detect a reversible Markov process but
 most Markov processes are not reversible.
 Thus a method is required to define a reversed process 
\begin_inset Formula $\{X_{\tau-t}\}$
\end_inset

 for a Markov process 
\begin_inset Formula $\{X_{t}\}$
\end_inset

 that is not reversible.
 The stationary distribution 
\begin_inset Formula $\pi$
\end_inset

 is the same for both the processes and thus the we can relate the instantaneous
 transition rates of the reversed process to those of the original process
 by the following Proposition 2.4.2.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Proposition 2.4.2
\end_layout

\begin_layout Plain Layout
The reversed process of a stationary Markov process 
\begin_inset Formula ${X_{t}}$
\end_inset

 with state space 
\begin_inset Formula $S$
\end_inset

, generator matrix 
\begin_inset Formula $Q$
\end_inset

 and stationary probabilities 
\series bold

\begin_inset Formula $\mathbf{\pi}$
\end_inset


\series default
 is a stationary Markov process with generator matrix 
\begin_inset Formula $Q′$
\end_inset

 defined by
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
q'_{ij}=\frac{\pi_{j}q_{ji}}{\pi_{i}} &  & \forall i,j\in S\label{eq:BalanceEquation_RP}
\end{eqnarray}

\end_inset

and with the same stationary probabilities 
\series bold

\begin_inset Formula $\mathbf{\pi}$
\end_inset


\series default
.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Kolmogorov’s criteria
\end_layout

\begin_layout Standard
The equilibrium distribution of a stationary Markov process can be found
 using the result (Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:BalanceEquation_RP"

\end_inset

) from Proposition 2.4.2 by 
\emph on
guessing
\emph default
 possible instantaneous transition rates 
\begin_inset Formula $\{q'_{ij}\mbox{ | }i,j\in S\}$
\end_inset

 for the reversed process and a collection of positive real numbers 
\begin_inset Formula $\{\pi_{i}\mbox{ | }i\in S\}$
\end_inset

 which sum finitely to 
\begin_inset Formula $G$
\end_inset

 such that
\end_layout

\begin_layout Itemize
The total rate out of state 
\begin_inset Formula $i$
\end_inset

 is the same for reversed and original process: 
\begin_inset Formula $q'_{i}=q_{i}\mbox{ }(\forall i\in S)$
\end_inset

 where 
\begin_inset Formula $q_{i}\equiv-q_{ii}$
\end_inset

 is the total rate out of state 
\begin_inset Formula $i$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\pi_{i}q'_{ij}\mbox{ }=\mbox{ }\pi_{j}q_{ji}\mbox{ }(\forall i\mbox{ , }j\in S\mbox{ , }i\neq j)$
\end_inset


\end_layout

\begin_layout Standard
These conditions ensure that 
\begin_inset Formula $\pi$
\end_inset

 satisfies the Markov process balance equations and thus the steady state
 probabilities are 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\{\pi_{i}/G\mbox{ | }i\in S\}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 by uniqueness, where G is the normalizing constant.
\end_layout

\begin_layout Standard
But this methodology depends on making the `right guesses' of the unknown
 vector 
\begin_inset Formula $\pi$
\end_inset

 - the equilibrium state probabilities.
 Since 
\begin_inset Formula $\pi$
\end_inset

 is defined by the generators of a Markov process, its instantaneous transition
 rates, another methodology which finds reversed processes without reference
 to 
\begin_inset Formula $\pi$
\end_inset

 can be useful.
 The following proposition, called 
\emph on
Kolmogorov’s criteria,
\emph default
 provides this by placing conditions only on the instantaneous rates of
 a Markov process.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Proposition 2.4.3 - Kolmogorov’s Generalised Criteria
\end_layout

\begin_layout Plain Layout
A stationary Markov process with state space 
\begin_inset Formula $S$
\end_inset

 and generator matrix 
\begin_inset Formula $Q$
\end_inset

 has a reversed process with generator matrix 
\begin_inset Formula $Q'$
\end_inset

 if and only if
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
q'_{i}=q_{i} &  & \forall i\in S
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
and for every finite sequence of states 
\begin_inset Formula $i_{1}\mbox{, }i_{2}\mbox{, ..., }i_{n}\in S$
\end_inset

 ,
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
q_{i_{1}i_{2}}q_{i_{2}i_{3}}\mbox{. . . }q_{i_{n-1}i_{n}}q_{i_{n}i_{1}} & = & q'_{i_{1}i_{n}}q'_{i_{n}i_{n-1}}\mbox{ . . . }q'_{i_{3}i_{2}}q'_{i_{2}i_{1}}\label{eq:KolmogorovCriteria_RP}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Plain Layout
where 
\begin_inset Formula $q_{i}\mbox{ }=\mbox{ }-q_{ii}\mbox{ }=\mbox{ }\sum_{j\mbox{ }:\mbox{ }j\neq i}q_{ij}$
\end_inset

 is the total exit rate from state 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As mentioned, Proposition 2.4.3 can be used to find the instantaneous transition
 rates of the reversed process 
\begin_inset Formula $Q'$
\end_inset

 and then use them to derive the SSPD of both original and reversed Markov
 Process.
 This can be done by using the Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:BalanceEquation_RP"

\end_inset

 or a modified approach given as follows:
\end_layout

\begin_layout Enumerate
We first arbitrarily choose a reference state 0
\end_layout

\begin_layout Enumerate
We then find a sequence of directly connected states 
\begin_inset Formula $0\mbox{, . . . , }j$
\end_inset

 in either the forward or reverse process
\end_layout

\begin_layout Enumerate
We then calculate the steady state probability 
\begin_inset Formula $\pi_{j}$
\end_inset

 related to a base value 
\begin_inset Formula $\pi_{0}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\pi_{j} & = & \pi_{0}\prod_{i=0}^{j-1}\frac{q_{i,i+1}}{q'_{i+1,i}}\\
 & = & \pi_{0}\prod_{i=0}^{j-1}\frac{q'_{i,i+1}}{q{}_{i+1,i}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/KolgomorovCriteriadrawing.svg
	scale 65
	rotateOrigin centerTop

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
A forward Markov process and its reversed counterpart
\begin_inset CommandInset label
LatexCommand label
name "fig:A-forward-Markov"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider a 3-state CTMC, as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-forward-Markov"

\end_inset

, with the only non-zero transition rates given by 
\begin_inset Formula $q_{12}=q_{23}=\lambda$
\end_inset

 and 
\begin_inset Formula $q_{32}=q_{31}=\mu$
\end_inset

.
 Thus using Kolmogorov Generalised Criteria (Proposition 2.4.3) to discover
 the reversed rates in its generator matrix 
\begin_inset Formula $Q'$
\end_inset

 , we start by comparing the outbound rates in the forward and reversed
 process:
\end_layout

\begin_layout Standard
\begin_inset Formula $q_{1}=\lambda\mbox{ , }q_{2}=\lambda\mbox{ , }q_{3}=2\mu$
\end_inset

 gives,
\begin_inset Formula 
\begin{eqnarray*}
q'_{1}=q'_{13}=q_{1}=\lambda\mbox{ , } & q'_{2}=q'_{21}+q'_{23}=q_{2}=\lambda\mbox{ , } & q'_{3}=q'_{32}=q_{3}=2\mu
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
There are two minimal cycles in the forward process, 
\begin_inset Formula $\{1\to2,\mbox{ }2\to3,\mbox{ }3\to1\}$
\end_inset

 and 
\begin_inset Formula $\{2\to3,\mbox{ }3\to2\}$
\end_inset

, which give the following cycle equations:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
q'_{13}q'_{32}q'_{21}=\lambda^{2}\mu &  & q'_{23}q'_{32}=\mu\lambda
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Solving these we get, 
\begin_inset Formula 
\[
q'_{13}=\lambda,\mbox{ }q'_{32}=2\mu,\mbox{ }q'_{21}=q'_{23}=\frac{\lambda}{2}
\]

\end_inset


\end_layout

\begin_layout Standard
This style of reasoning is used to prove the RCAT and to determine the reversed
 rates of PEPA actions in sequential PEPA components, described in later
 sections.
\end_layout

\begin_layout Section
Queuing Networks
\end_layout

\begin_layout Standard
Queuing networks 
\begin_inset CommandInset citation
LatexCommand cite
key "PerformanceModellingHarrisonBook,LectureNotes"

\end_inset

 are systems that are network of queues with connected inputs and outputs.
 
\emph on
Open
\emph default
 queuing networks are queuing networks where external customers are allowed
 to arrive or depart the system while 
\emph on
closed
\emph default
 queuing networks are those where no external customers are allowed in the
 system.
\end_layout

\begin_layout Subsection
Traffic Equations
\end_layout

\begin_layout Standard
Traffic equations are a system of linear equations used to compute the mean
 arrival rate values 
\begin_inset Formula $\lambda_{i}$
\end_inset

 to each node 
\begin_inset Formula $i$
\end_inset

 in the network.
 In queuing networks, for any node 
\begin_inset Formula $i$
\end_inset

, the mean number of arrivals to node 
\begin_inset Formula $i$
\end_inset

 is the sum of the mean external arrivals to node 
\begin_inset Formula $i$
\end_inset

 and the mean arrivals from all other nodes 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\begin_layout Standard
So the traffic equations for node 
\begin_inset Formula $i=1\mbox{, }2\mbox{, . . . , }M$
\end_inset

 is defined as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\lambda_{i} & = & \gamma_{i}+\sum_{j=1}^{M}\lambda_{j}q_{ji}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\gamma_{i}$
\end_inset

 is the external arrival rate at node 
\begin_inset Formula $i$
\end_inset

, and 
\begin_inset Formula $q_{ji}$
\end_inset

 is the routing probability that traffic leaving node 
\begin_inset Formula $j$
\end_inset

 is routed to node 
\begin_inset Formula $i$
\end_inset

.
 In closed queuing networks, the external arrival rate 
\begin_inset Formula $\gamma_{i}$
\end_inset

 will be zero.
\end_layout

\begin_layout Subsection
Jackson Theorem
\end_layout

\begin_layout Standard
Using the traffic equations, the utilisation of node 
\begin_inset Formula $i$
\end_inset

 can be derived.
 For open queuing networks having nodes with fixed service rates 
\begin_inset Formula $\mu_{i}$
\end_inset

, the traffic intensity is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\rho_{i} & = & \frac{\lambda_{i}}{\mu_{i}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
The utilisation therefore at node 
\begin_inset Formula $i$
\end_inset

 is 
\begin_inset Formula $U_{i}=\mbox{traffic intensity at node }i=\rho_{i}$
\end_inset

.
 A network is 
\emph on
stable
\emph default
, which means capable of reaching a steady state, if the following condition
 holds:
\end_layout

\begin_layout Standard
Utilisation at all nodes should be:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\rho_{i}=\frac{\lambda_{i}}{\mu_{i}}<1 &  & :\forall i
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
To calculate the steady state probability distribution of a stable network,
 the Jackson's theorem is used, which gives a product form solution for
 open queuing networks.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Theorem 2.5.1 Jackson Theorem
\end_layout

\begin_layout Plain Layout
If the open queuing network is stable, that is if the condition:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\rho_{i}<1 &  & :\forall i
\end{eqnarray*}

\end_inset

holds, then the steady-state exists and
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
\pi(n_{1}\mbox{, . . . , }n_{m}) & = & \prod_{i=1}^{M}(1-\rho_{i})\rho_{i}^{n_{i}}\label{eq:ProductFormSolutionJThm}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Plain Layout
is the joint probability (or steady state probabilities) where
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\pi(n_{1}\mbox{, . . . , }n_{m})$
\end_inset

 is the probability that the system has queue length 
\begin_inset Formula $n_{i}$
\end_inset

 at node 
\begin_inset Formula $i$
\end_inset

 .
 The result is also called the
\emph on
 product form solution
\emph default
 of the model.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The product-form result implies that each node can be reasoned about as
 a M/M/1 queue in isolation and thus makes obtaining performance measures
 of a network such as - mean queue lengths, throughput, mean waiting time
 - an easy task.
 If we analyse the product form solution, we notice that the marginal distributi
on of the number of jobs at node 
\begin_inset Formula $i$
\end_inset

 is the same as that of an M/M/1 queue (compare the SSPD solution of a M/M/1
 queue from 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:SSPD_of_MM1Q"

\end_inset

 to the inner term of the product form solution obtained 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ProductFormSolutionJThm"

\end_inset

).
 Thus we can conclude that for a stable Jackson Network with an arrival
 rate 
\begin_inset Formula $\lambda_{i}$
\end_inset

 to node 
\begin_inset Formula $i$
\end_inset

:
\end_layout

\begin_layout Itemize
The number of of jobs at any node is independent of the state of any other
 node as we get a product form solution
\end_layout

\begin_layout Itemize
Node 
\begin_inset Formula $i$
\end_inset

 behaves stochastically as if it were subject to Poisson arrivals with rate
 
\begin_inset Formula $\lambda_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
We can now define (an open) 
\emph on
Jackson Network
\begin_inset CommandInset citation
LatexCommand cite
key "PerformanceModellingHarrisonBook"

\end_inset


\emph default
 as an open queuing network with any external arrivals to any node 
\begin_inset Formula $i$
\end_inset

 forming a Poisson stream and the equilibrium probability distribution resulting
 in to a product form solution model.
 It is a relatively simple queuing network and we shall derive its product
 form solution using the RCAT theorem in later sections.
\end_layout

\begin_layout Subsection
G-Network
\end_layout

\begin_layout Standard
A G-network 
\begin_inset CommandInset citation
LatexCommand cite
key "GelenbeGNetworks"

\end_inset

, also known as a generalised queueing network or Gelenbe network and introduced
 by Erol Gelenbe, are queuing networks with negative customers.
 Thus this network has two types of customers:
\end_layout

\begin_layout Itemize

\emph on
positive customers
\emph default
 are customers as in a M/M/1 queue which arrive from other queues or externally
 as Poisson arrivals.
 Their departures (state decrements) are synchronised with state increments
 (arrivals) in the destination queue.
\end_layout

\begin_layout Itemize

\emph on
negative customers
\emph default
 are those customers which remove or `cancel' positive customers in the
 queue if it is not empty and have no effect on an empty queue.
 They are useful to remove traffic if a network is congested.
\end_layout

\begin_layout Standard
A product form solution exists for stationary G-networks despite the traffic
 flows forming a system of non-linear equations.
 
\end_layout

\begin_layout Section
Formalisms and product-forms
\end_layout

\begin_layout Subsection
PEPA
\end_layout

\begin_layout Standard
PEPA
\begin_inset CommandInset citation
LatexCommand cite
key "HillstonPEPAbook,HarrisonPaperTBTinMAP2003,BradleyRP&RCAT,HarrisonPaperPerformanceImpact2009"

\end_inset

 is a formal system description language used in performance modelling 
\begin_inset CommandInset citation
LatexCommand cite
key "HillstonPEPAbook"

\end_inset

.
 It is a Markovian Process Algebra (MPA) with the fewest combinators necessary
 to provide a semantic model for denoting the states of a continuous time
 Markov Chain 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperPerformanceImpact2009"

\end_inset

.
 As the Jackson Theorem (see Theorem 2.5.1) operates over queuing networks
 to generate product form solutions, RCAT operates over PEPA.
\end_layout

\begin_layout Standard
In PEPA, a system is an interaction of 
\emph on
components
\emph default
 which engage in 
\emph on
activities.

\emph default
 For example, in a stochastic process components correspond to states while
 activities correspond to transitions between them.
 An activity in PEPA is specified as 
\begin_inset Formula $\alpha=(a,r)$
\end_inset

 , where 
\begin_inset Formula $a$
\end_inset

 is the 
\emph on
action type 
\emph default
and
\emph on
 
\begin_inset Formula $r$
\end_inset

 
\emph default
is the 
\emph on
activity rate
\emph default
.
 The Markov process's transition rates are represented in PEPA by the activity
 rate as a duration which is a random variable with an exponential distribution.
 Every activity within the PEPA model with the same action type represents
 different instances of that action in the system.
 A 
\emph on
derivation graph
\emph default
, formed by PEPA terms at nodes (states of an MP) and arcs showing transitions
 between them, determine the underlying Markov process of a component P.
\end_layout

\begin_layout Subsubsection
PEPA Syntax
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.6.1
\end_layout

\begin_layout Plain Layout
The syntax
\begin_inset CommandInset citation
LatexCommand cite
key "BradleyRP&RCAT"

\end_inset

 of a PEPA component 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $P$
\end_inset

 is represented by:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
P & ::= & (a,\lambda).P\mbox{ | }P_{1}\mbox{ }+\mbox{ }P_{2}\mbox{ | }P_{1}\ensuremath{\sync{\mathcal{L}}}P_{2}\mbox{ | }P/L\mbox{ | }A
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $(a,\lambda).P$
\end_inset

 is called a 
\emph on
prefix 
\emph default
operation.
 It represents a process which performs an action 
\begin_inset Formula $a$
\end_inset

 with a rate parameter 
\begin_inset Formula $\lambda$
\end_inset

 and then becomes a new process 
\begin_inset Formula $P$
\end_inset

.
 The rate parameter may either be a positive real number or the value 
\begin_inset Formula $\top$
\end_inset

 which makes the action passive in a cooperation.
\end_layout

\begin_layout Standard
\begin_inset Formula $P_{1}+P_{2}$
\end_inset

 is a 
\emph on
choice
\emph default
 operation.
 Here the two components 
\begin_inset Formula $P_{1}$
\end_inset

 and 
\begin_inset Formula $P_{2}$
\end_inset

 are in a race condition where the process can evolve into either one of
 them.
 The first component to activate will dictate the direction of choice
\end_layout

\begin_layout Standard
\begin_inset Formula $P_{1}\ensuremath{\sync{\mathcal{L}}}P_{2}$
\end_inset

 is the 
\emph on
cooperation 
\emph default
or synchronisation operation.
 
\begin_inset Formula $P_{1}$
\end_inset

 and 
\begin_inset Formula $P_{2}$
\end_inset

 run in parallel and synchronise over actions in set 
\begin_inset Formula $\mathcal{{L}}$
\end_inset

.
 Synchronising actions must be activated jointly by both components.
 Thus if component 
\begin_inset Formula $P_{1}$
\end_inset

 can evolve only by activating a synchronising action 
\begin_inset Formula $a$
\end_inset

, it may be blocked until 
\begin_inset Formula $P_{2}$
\end_inset

 is in a derivative state that can synchronise on 
\begin_inset Formula $a$
\end_inset

.
 In a passive cooperation, if 
\begin_inset Formula $P_{1}$
\end_inset

 evolves with a rate 
\begin_inset Formula $\top$
\end_inset

 on synchronising action 
\begin_inset Formula $a$
\end_inset

, then the joint action 
\begin_inset Formula $a$
\end_inset

 inherits its rate from the 
\begin_inset Formula $P_{2}$
\end_inset

 component alone.
 Parallelism is a special case of synchronisation where the set of synchronising
 actions is empty, that is, 
\begin_inset Formula $P_{1}\ensuremath{\sync{\emptyset}}P_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $P/L$
\end_inset

 is the 
\emph on
hiding
\emph default
 operation.
 Observable actions from set 
\begin_inset Formula $L$
\end_inset

 in 
\begin_inset Formula $P$
\end_inset

 are rewritten as silent 
\begin_inset Formula $\tau$
\end_inset

 actions which cannot be used in cooperations with other components.
\end_layout

\begin_layout Standard
\begin_inset Formula $A$
\end_inset

 is a 
\emph on
constant
\emph default
 label that is used while constructing recursive definitions.
\end_layout

\begin_layout Standard
Processes or 
\emph on
agents
\emph default
 defined using only assignments or prefixes are called simple agents while
 the ones defined using at least one cooperation combinator are called compound
 agents.
\end_layout

\begin_layout Subsubsection
PEPA activity substitution
\end_layout

\begin_layout Standard
Relabelling
\begin_inset CommandInset citation
LatexCommand cite
key "BradleyRP&RCAT"

\end_inset

 or activity substitution is a method for an activity 
\begin_inset Formula $\alpha=(a,r)$
\end_inset

 to be syntactically replaced with activity 
\begin_inset Formula $\alpha'=(a'\mbox{ , }r')$
\end_inset

.
 This is particularly useful in defining reversed processes of cooperations.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.6.2
\end_layout

\begin_layout Plain Layout
The PEPA activity substitution function is defined as:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
(\beta.P)\{\alpha\leftarrow\alpha'\} & = & \begin{cases}
\alpha'.(P\{\alpha\leftarrow\alpha'\}) & :\mbox{ if }\alpha=\beta\\
\beta.(P\{\alpha\leftarrow\alpha'\}) & :\mbox{ }otherwise
\end{cases}\\
(P+Q)\{\alpha\leftarrow\alpha'\} & = & P\{\alpha\leftarrow\alpha'\}+Q\{\alpha\leftarrow\alpha'\}\\
\\
(P_{1}\ensuremath{\sync{\mathcal{L}}}P_{2})\{\alpha\leftarrow\alpha'\} & = & P\{\alpha\leftarrow\alpha'\}\sync{\mathcal{{L}}\{\alpha\leftarrow\alpha'\}}Q\{\alpha\leftarrow\alpha'\}\\
where\mbox{ }\mathcal{L}\{(a,\lambda)\leftarrow(a',\lambda')\} & = & \begin{cases}
(\mathcal{L}\backslash\{a\})\mbox{ }\bigcup\mbox{ }\{a'\} & :\mbox{ }if\mbox{ }a\in\mathcal{L}\\
\mathcal{L} & :\mbox{ }otherwise
\end{cases}\\
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reversing a PEPA component
\end_layout

\begin_layout Standard
Reversing a PEPA component is done for finding the reversed process of a
 Markov process in terms of a PEPA agent with appropriate rates.
 The RCAT theorem deals with the reversal of a compound agent, 
\begin_inset Formula $P_{1}\ensuremath{\sync{\mathcal{L}}}P_{2}$
\end_inset

 , and uses reversing sequential components in its definition.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.6.3
\end_layout

\begin_layout Plain Layout
For all states 
\begin_inset Formula $S$
\end_inset

 in a sequential component:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\overline{S} & \rmdef & \sum_{i\mbox{ : }R_{i}\to^{(a_{i},\lambda_{i})}S}(\overline{a}_{i}\mbox{ , }\overline{\lambda_{i}}).\overline{R_{i}}
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus the reversed rate of a component 
\begin_inset Formula $\bar{S}$
\end_inset

 is a choice between all the states that have 
\begin_inset Formula $S$
\end_inset

 as its immediate successor in the forward process 
\begin_inset CommandInset citation
LatexCommand cite
key "BradleyRP&RCAT"

\end_inset

.
 Thus in the reversed component, actions 
\begin_inset Formula $a$
\end_inset

 become 
\begin_inset Formula $\bar{a}$
\end_inset

 and rates 
\begin_inset Formula $\lambda$
\end_inset

 become 
\begin_inset Formula $\bar{\lambda}$
\end_inset

 where 
\begin_inset Formula $\bar{\lambda}$
\end_inset

 can be calculated using Kolmogorov’s generalised criteria (Proposition
 2.4.3 - Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KolmogorovCriteria_RP"

\end_inset

 for example).
 Finding the rates of a reversed compound agent requires a new rule as an
 agent may have several actions leading to the same state that synchronise
 with distinct actions in a cooperating agent 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.6.4
\end_layout

\begin_layout Plain Layout
The reversed actions of multiple actions 
\begin_inset Formula $(a_{i},\lambda_{i})$
\end_inset

, for 
\begin_inset Formula $1\leq i\leq n$
\end_inset

 that an agent 
\begin_inset Formula $P$
\end_inset

 can perform, which lead to the same derivative 
\begin_inset Formula $Q$
\end_inset

, are respectively
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
(\bar{a_{i}}\mbox{, }(\lambda_{i}/\lambda)\bar{\lambda}))
\]

\end_inset


\end_layout

\begin_layout Plain Layout
where 
\begin_inset Formula $\lambda=\lambda_{1}+\mbox{ . . . }+\lambda_{n}$
\end_inset

 and 
\begin_inset Formula $\bar{\lambda}$
\end_inset

 is the reversed rate of the one-step, composite transition with rate 
\begin_inset Formula $\lambda$
\end_inset

 in the Markov chain, corresponding to all the arcs between 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Definition 2.6.4 is used in the RCAT theorem for reversing compound agents.
\end_layout

\begin_layout Subsection
Reversed Compound Agent Theorem (RCAT)
\end_layout

\begin_layout Standard
The Reversed Compound Agent Theorem (RCAT) finds the reversed compound agent
 of the cooperation 
\begin_inset Formula $P\ensuremath{\sync{L}}Q$
\end_inset

 by finding the reversed rates of the constituent processes 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 For RCAT operation, we define some restrictions on actions in a component.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.6.5
\end_layout

\begin_layout Plain Layout
The subset of action types in a set 
\begin_inset Formula $L$
\end_inset

 which are passive with respect to a process 
\begin_inset Formula $P$
\end_inset

 (i.e.
 are of the form 
\begin_inset Formula $(a,\top)$
\end_inset

 in 
\begin_inset Formula $P$
\end_inset

) is denoted by 
\begin_inset Formula $\mathcal{P}_{P}(L)$
\end_inset

.
 The set of corresponding active action types is denoted by 
\begin_inset Formula $\mathcal{A}{}_{P}(L)=L\backslash\mathcal{P}_{P}(L)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus an action cannot be both passive and active in the same component.
 If an action is active in a component, all its instances are active in
 that component, and if it is passive then all its instances are passive.
 This is necessary as we, in RCAT, syntactically transform every passive
 action before reversing an agent to ensure every passive action rate is
 uniquely identified with all instances of its action type 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

.
\end_layout

\begin_layout Subsubsection
The RCAT theorem
\end_layout

\begin_layout Standard
The RCAT as stated in the original paper 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Theorem 2.6.1 Reversed Compound Agent Theorem
\end_layout

\begin_layout Plain Layout
Suppose that the cooperation 
\begin_inset Formula $P\ensuremath{\sync{L}}Q$
\end_inset

 has a derivation graph with an irreducible subgraph G.
 Given that:
\end_layout

\begin_layout Enumerate
every passive action type in 
\begin_inset Formula $\mathcal{P}_{P}(L)$
\end_inset

 or 
\begin_inset Formula $\mathcal{P}_{Q}(L)$
\end_inset

 is always enabled in 
\begin_inset Formula $P$
\end_inset

 or 
\begin_inset Formula $Q$
\end_inset

 respectively (i.e.
 enabled in all states of the transition graph);
\end_layout

\begin_layout Enumerate
every reversed action of an active action type in 
\begin_inset Formula $\mathcal{A}{}_{P}(L)$
\end_inset

 or 
\begin_inset Formula $\mathcal{A}{}_{Q}(L)$
\end_inset

 is always enabled in 
\begin_inset Formula $\overline{P}$
\end_inset

 or 
\begin_inset Formula $\overline{Q}$
\end_inset

 respectively;
\end_layout

\begin_layout Enumerate
every occurrence of a reversed action of an active action type in 
\begin_inset Formula $\mathcal{A}{}_{P}(L)$
\end_inset

 or 
\begin_inset Formula $\mathcal{A}{}_{Q}(L)$
\end_inset

 has the same rate in 
\begin_inset Formula $\overline{P}$
\end_inset

 or 
\begin_inset Formula $\overline{Q}$
\end_inset

 respectively.
\end_layout

\begin_layout Plain Layout
the reversed agent 
\begin_inset Formula $\overline{P\sync{L}Q}$
\end_inset

, with derivation graph containing the reversed subgraph 
\begin_inset Formula $\overline{G}$
\end_inset

, is: 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
R^{*}\sync{\overline{L}}S^{*}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
where:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
R^{*} & = & \overline{R}\{(\overline{a},\bar{p}_{a})\leftarrow(\bar{a},\top)\mbox{ }|\mbox{ }a\in\mathcal{A}{}_{P}(L)\}\\
S^{*} & = & \overline{S}\{(\overline{a},\bar{q}_{a})\leftarrow(\bar{a},\top)\mbox{ }|\mbox{ }a\in\mathcal{A}{}_{Q}(L)\}\\
R & = & P\{(a,\top)\leftarrow(a,x_{a})\mbox{ }|\mbox{ }a\in\mathcal{P}{}_{P}(L)\}\\
S & = & Q\{(a,\top)\leftarrow(a,x_{a})\mbox{ }|\mbox{ }a\in\mathcal{P}{}_{Q}(L)\}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
where the symbolic rates 
\begin_inset Formula $\{x_{a}\}$
\end_inset

 are given by:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
x_{a} & = & \begin{cases}
\bar{q}_{a} & :\mbox{ if }a\in\mathcal{P}_{P}(L)\\
\bar{p}_{a} & :\mbox{ if }a\in\mathcal{P}_{Q}(L)
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
and 
\begin_inset Formula $\bar{p}_{a}$
\end_inset

 and 
\begin_inset Formula $\bar{q}_{a}$
\end_inset

 are symbolic rates of action types 
\begin_inset Formula $\bar{a}$
\end_inset

 in 
\begin_inset Formula $\overline{P}$
\end_inset

 and 
\begin_inset Formula $\overline{Q}$
\end_inset

 respectively.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The proof of this theorem is detailed in the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

 and consists of verifying that Kolmogorov’s criteria hold.
\end_layout

\begin_layout Subsubsection
(E)RCAT - Extended RCAT
\end_layout

\begin_layout Standard
Conditions 1 and 2 in the RCAT (Theorem 2.6.1) requires every passive action
 to be enabled in every derivative (state) of both the forward and reversed
 cooperating agents.
 This ensures that the total outgoing rate from any state is the same in
 the two processes in agent 
\begin_inset Formula $P\ensuremath{\sync{L}}Q$
\end_inset

 and its reversed agent.
 But as stated in paper 
\begin_inset CommandInset citation
LatexCommand cite
key "ercat"

\end_inset

, relaxing these conditions allows RCAT to be applied on a large breadth
 of systems.
 We define some new notation to account for the action types in 
\begin_inset Formula $L$
\end_inset

 that might not be present in every derivative of the forward and reversed
 cooperating agents.
 This is an extension to Definition 2.6.5
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.6.6
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathcal{P}_{A}^{i\rightarrow}$
\end_inset

 denotes the subset that are passive in 
\begin_inset Formula $A$
\end_inset

 and correspond to transitions out of state 
\begin_inset Formula $i$
\end_inset

 in the Markov process 
\begin_inset Formula $A$
\end_inset

 ;
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathcal{P}_{A}^{i\leftarrow}$
\end_inset

 denotes the subset that are passive in 
\begin_inset Formula $A$
\end_inset

 and correspond to transitions into state 
\begin_inset Formula $i$
\end_inset

 in the Markov process 
\begin_inset Formula $A$
\end_inset

 ;
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathcal{A}_{A}^{i\rightarrow}$
\end_inset

 denotes the subset that are active in 
\begin_inset Formula $A$
\end_inset

 and correspond to transitions out of state 
\begin_inset Formula $i$
\end_inset

 in the Markov process 
\begin_inset Formula $A$
\end_inset

 ;
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathcal{A}_{A}^{i\rightarrow}$
\end_inset

 denotes the subset that are active in 
\begin_inset Formula $A$
\end_inset

 and correspond to transitions into state 
\begin_inset Formula $i$
\end_inset

 in the Markov process 
\begin_inset Formula $A$
\end_inset

;
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathcal{P}^{(i,j)\rightarrow}=\mathcal{P}_{P}^{i\rightarrow}+\mathcal{P}_{Q}^{j\rightarrow}$
\end_inset

 and 
\begin_inset Formula $\mathcal{A}^{(i,j)\rightarrow}=\mathcal{A}_{P}^{i\rightarrow}+\mathcal{A}_{Q}^{j\rightarrow}$
\end_inset

 ; 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathcal{P}^{(i,j)\leftarrow}=\mathcal{P}_{P}^{i\leftarrow}+\mathcal{P}_{Q}^{j\leftarrow}$
\end_inset

 and 
\begin_inset Formula $\mathcal{A}^{(i,j)\leftarrow}=\mathcal{A}_{P}^{i\leftarrow}+\mathcal{A}_{Q}^{j\leftarrow}$
\end_inset

 ;
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{a}^{(i,j)}$
\end_inset

 denotes the instantaneous transition rate out of (joint) state 
\begin_inset Formula $(i,j)$
\end_inset

 in the Markov process of 
\begin_inset Formula $P\ensuremath{\sync{L}}Q$
\end_inset

 corresponding to active action type 
\begin_inset Formula $a\in L$
\end_inset

;
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\overline{\beta_{a}^{(i,j)}}$
\end_inset

 denotes the instantaneous transition rate out of (joint) state 
\begin_inset Formula $(i,j)$
\end_inset

 in the reversed Markov process of 
\begin_inset Formula $P\ensuremath{\sync{L}}Q$
\end_inset

 corresponding to passive action type 
\begin_inset Formula $a\in L$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The theorem with the new notation is defined as follows:
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Theorem 2.6.2 Extended
\series default
 
\series bold
Reversed Compound Agent Theorem
\series default
\emph on

\begin_inset CommandInset citation
LatexCommand cite
key "RCAT2009Paper"

\end_inset


\end_layout

\begin_layout Plain Layout
If the following conditions hold,
\end_layout

\begin_layout Enumerate
The reversed rate 
\begin_inset Formula $x_{a}$
\end_inset

 of every active action 
\begin_inset Formula $a$
\end_inset

 is the same at every instance, given by the solution of the rate equations,
 as in the original RCAT (Theorem 2.6.1).
\end_layout

\begin_layout Enumerate
The forward and reversed passive and active transition rates satisfy:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\sum_{a\in\mathcal{P}^{(i,j)\rightarrow}}x_{a}-\sum_{a\in\mathcal{A}^{(i,j)\leftarrow}}x_{a} & = & \sum_{a\in\mathcal{P}^{(i,j)\leftarrow}\backslash\mathcal{A}^{(i,j)\leftarrow}}\overline{\beta_{a}^{(i,j)}}-\sum_{a\in\mathcal{A}^{(i,j)\rightarrow}\backslash\mathcal{P}^{(i,j)\rightarrow}}\alpha_{a}^{(i,j)}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
Then the reversed process of the cooperation 
\begin_inset Formula $P\ensuremath{\sync{L}}Q$
\end_inset

 is
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\overline{P\sync{L}Q} & = & R^{*}\sync{\overline{L}}S^{*}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
where:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
R^{*} & = & \overline{R}\{(\overline{a},\bar{p}_{a})\leftarrow(\bar{a},\top)\mbox{ }|\mbox{ }a\in\mathcal{A}{}_{P}(L)\}\\
S^{*} & = & \overline{S}\{(\overline{a},\bar{q}_{a})\leftarrow(\bar{a},\top)\mbox{ }|\mbox{ }a\in\mathcal{A}{}_{Q}(L)\}\\
R & = & P\{(a,\top)\leftarrow(a,x_{a})\mbox{ }|\mbox{ }a\in\mathcal{P}{}_{P}(L)\}\\
S & = & Q\{(a,\top)\leftarrow(a,x_{a})\mbox{ }|\mbox{ }a\in\mathcal{P}{}_{Q}(L)\}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
where the symbolic rates 
\begin_inset Formula $\{x_{a}\}$
\end_inset

 are given by:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
x_{a} & = & \begin{cases}
\bar{q}_{a} & :\mbox{ if }a\in\mathcal{P}_{P}(L)\\
\bar{p}_{a} & :\mbox{ if }a\in\mathcal{P}_{Q}(L)
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
and 
\begin_inset Formula $\bar{p}_{a}$
\end_inset

 and 
\begin_inset Formula $\bar{q}_{a}$
\end_inset

 are symbolic rates of action types 
\begin_inset Formula $\bar{a}$
\end_inset

 in 
\begin_inset Formula $\overline{P}$
\end_inset

 and 
\begin_inset Formula $\overline{Q}$
\end_inset

 respectively.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Practical Application of the RCAT method
\end_layout

\begin_layout Standard
For using the RCAT method practically, the algorithm detailed below can
 be used.
 This algorithm does not require the whole reversed processes to be determined
 in RCAT Theorem 2.6.1 but does require the specific reversed rates of the
 synchronising active actions.
 These rates are computed using equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:BalanceEquation_RP"

\end_inset

 which use the equilibrium state probabilities of each component process.
 
\end_layout

\begin_layout Standard

\series bold
Generic Algorithm
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "RCAT2009Paper"

\end_inset


\end_layout

\begin_layout Standard
Consider the cooperation 
\begin_inset Formula $P_{1}\sync{L}P_{2}$
\end_inset

.
 The algorithm is as follows
\end_layout

\begin_layout Enumerate
From 
\begin_inset Formula $P_{k}$
\end_inset

 construct 
\begin_inset Formula $R_{k}$
\end_inset

 by setting the rate of every instance of action 
\begin_inset Formula $a\in L$
\end_inset

 that is passive in 
\begin_inset Formula $P_{k}$
\end_inset

 to 
\begin_inset Formula $x_{a}$
\end_inset

, for 
\begin_inset Formula $k=1,2$
\end_inset

 (each 
\begin_inset Formula $a$
\end_inset

 will be passive for only one 
\begin_inset Formula $k$
\end_inset

);
\end_layout

\begin_layout Enumerate
For each active action type 
\begin_inset Formula $a$
\end_inset

 in 
\begin_inset Formula $R_{k}\mbox{ , }k=1,2$
\end_inset

, check that its reversed rate is the same for all of its instances, that
 is for for all transitions 
\begin_inset Formula $i\rightarrow j$
\end_inset

 it denotes states 
\begin_inset Formula $i,j$
\end_inset

 in the state transition graph of 
\begin_inset Formula $R_{k}$
\end_inset

.
 Compute and denote this reversed rate (in the reversed process 
\begin_inset Formula $\overline{R_{k}}$
\end_inset

) by the equation 
\begin_inset Formula 
\begin{eqnarray}
\overline{r_{a}^{i}} & = & \frac{\pi_{k}(i)r_{a}^{i}}{\pi_{k}(j)}\label{eq:GenericAlgoRRCal}
\end{eqnarray}

\end_inset

where 
\begin_inset Formula $r_{a}^{i}$
\end_inset

 is the specified forward rate (any, if more than one) of the instance of
 action type 
\begin_inset Formula $a$
\end_inset

 going out of state 
\begin_inset Formula $i$
\end_inset

.
 In fact, if the reversed process of the cooperation is required, the full
 reversed processes 
\begin_inset Formula $R_{k}$
\end_inset

 must be computed;
\end_layout

\begin_layout Enumerate
Noting that the symbolic reversed rate 
\begin_inset Formula $\overline{r_{a}}$
\end_inset

 will in general be a function of the 
\begin_inset Formula $x_{b}(b\in L)$
\end_inset

, solve the equations 
\begin_inset Formula $x_{a}=\overline{r_{a}}$
\end_inset

 for each 
\begin_inset Formula $a\in L$
\end_inset

 and substitute the solutions for the variables 
\begin_inset Formula $x_{a}$
\end_inset

 in each 
\begin_inset Formula $R_{k}$
\end_inset

;
\end_layout

\begin_layout Enumerate
Check the enabling conditions (detailed in 
\begin_inset CommandInset citation
LatexCommand cite
key "marcatHarLee2005"

\end_inset

) for each co-operating action in each process 
\begin_inset Formula $P_{k}$
\end_inset

.
 For queueing networks, these are as in the original RCAT, namely that all
 passive actions be enabled in all states and that all states also have
 an incoming instance of every active action;
\end_layout

\begin_layout Enumerate
The required product-form for state 
\begin_inset Formula $\underline{s}=(s1\mbox{ , }s2)$
\end_inset

 is now 
\begin_inset Formula $\pi(\underline{s})\propto\pi_{1}(s_{1})\pi_{2}(s_{2})$
\end_inset

 where 
\begin_inset Formula $\pi_{k}(s_{k})$
\end_inset

 is the equilibrium probability (which may be unnormalised) of state 
\begin_inset Formula $s_{k}$
\end_inset

 in 
\begin_inset Formula $R_{k}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Example
\series default
 
\begin_inset CommandInset citation
LatexCommand cite
key "BradleyRP&RCAT"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/tandemMM2Network.svg
	scale 55

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
A simple tandem queue system
\begin_inset CommandInset label
LatexCommand label
name "fig:simple-tandemQ"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider a tandem queue system, as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simple-tandemQ"

\end_inset

, which has 2 M/M/1 queuing nodes where input in queue 2 is coming from
 output from queue 1.
 Queue 1 has an external arrival rate of 
\begin_inset Formula $\lambda$
\end_inset

 and queuing nodes 
\begin_inset Formula $i$
\end_inset

, where 
\begin_inset Formula $1\leq i\leq2$
\end_inset

, have a service rate of 
\begin_inset Formula $\mu_{i}$
\end_inset

.
 Let external arrival be represented by action 
\begin_inset Formula $e$
\end_inset

, internal transfer between queues be action 
\begin_inset Formula $a$
\end_inset

 and departure from the system be action 
\begin_inset Formula $d$
\end_inset

.
 This system can be modelled in PEPA as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Sys & \rmdef & P_{0}\sync{a}Q_{0}\\
P_{0} & \rmdef & (e,\lambda).P_{1}\\
P_{n} & \rmdef & (e,\lambda).P_{n+1}+(a,\mu_{1}).P_{n-1}\\
Q_{0} & \rmdef & (a,\top).Q_{1}\\
Q_{n} & \rmdef & (a,\top).Q_{n+1}+(d,\mu_{2}).Q_{n-1}
\end{eqnarray*}

\end_inset

 Using Step 1 of the algorithm and activity substitution we get,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\\
R_{0} & \rmdef & (e,\lambda).R_{1}\\
R_{n} & \rmdef & (e,\lambda).R_{n+1}+(a,\mu_{1}).R_{n-1}\\
S_{0} & \rmdef & (a,x_{a}).S_{1}\\
S_{n} & \rmdef & (a,x_{a}).Q_{n+1}+(d,\mu_{2}).Q_{n-1}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Step 2: Now we need to find reversed rates for action type 
\begin_inset Formula $a$
\end_inset

.
 Since both the queuing nodes are M/M/1 queues, their equilibrium state
 probabilities are known to be 
\begin_inset Formula $\pi_{1}(q)=(1-\rho_{1})\rho_{1}^{q}$
\end_inset

 for node 1 and 
\begin_inset Formula $\pi_{2}(q)=(1-\rho_{2})\rho_{2}^{q}$
\end_inset

 for node 2 (refer equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:SSPD_of_MM1Q"

\end_inset

), where 
\begin_inset Formula $\rho_{1}=\frac{\lambda}{\mu_{1}}$
\end_inset

 and 
\begin_inset Formula $\rho_{2}=\frac{x_{a}}{\mu_{2}}$
\end_inset

 , since the arrival and service rates are state independent.
\end_layout

\begin_layout Standard
\begin_inset Formula $\implies$
\end_inset

 
\begin_inset Formula 
\begin{eqnarray*}
\overline{r_{a}} & = & \frac{\pi_{1}(n+1)r_{a}^{n+1}}{\pi_{1}(n)}\\
 & = & \rho\mu_{1}\\
 & = & \lambda
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Step 3: Solving equation 
\begin_inset Formula $x_{a}=\overline{r_{a}}$
\end_inset

 and executing step 3 of the algorithm we get,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
x_{a} & = & \lambda
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Finally, we can calculate the product form solution result by step 5,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\pi(P_{m},\mbox{ }Q_{n}) & = & \pi(P_{m})\pi(Q_{n})\\
 & = & \pi_{1}(m)\pi_{2}(n)\\
 & = & (1-\rho_{1})\rho_{1}^{m}(1-\rho_{2})\rho_{2}^{n}\\
 & = & (1-\rho_{1})\rho_{1}^{0}(1-\rho_{2})\rho_{2}^{0}\rho_{1}^{m}\rho_{2}^{n}\\
 & = & \pi(P_{0},\mbox{ }Q_{0})\rho_{1}^{m}\rho_{2}^{n}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
where where 
\begin_inset Formula $\rho_{1}=\frac{\lambda}{\mu_{1}}$
\end_inset

 and 
\begin_inset Formula $\rho_{2}=\frac{x_{a}}{\mu_{2}}=\frac{\lambda}{\mu_{2}}$
\end_inset

.
 The derived product form solution aggress with Jackson's Theorem (Theorem
 2.5.1, equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ProductFormSolutionJThm"

\end_inset

) confirming its validity.
\end_layout

\begin_layout Subsection
Stochastic Petri nets (SPNs)
\end_layout

\begin_layout Standard
Stochastic Petri Nets 
\begin_inset CommandInset citation
LatexCommand cite
key "SPNs"

\end_inset

 (SPNs) are a popular higher level formalism for Markovian (and other interactin
g) systems apart from Stochastic Process Algebra like PEPA.
 They are more expressive in a natural graphical way than SPAs but are more
 difficult to analyse structurally.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.6.7
\end_layout

\begin_layout Plain Layout
A stochastic Petri net can be defined as a tuple, 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $SPN=(\mathcal{P},\mathcal{T},\mathcal{X}(\mbox{ }.\mbox{ }),\mathrm{I}(\mbox{ }.\mbox{ }),\mathrm{O}(\mbox{ }.\mbox{ }),m_{0})$
\end_inset

 where:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{P}=\{P_{1},\mbox{ . . . },P_{N}\}$
\end_inset

 is a set of N places,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{T}=\{T_{1},\mbox{ . . . },T_{M}\}$
\end_inset

 is a set of M transitions,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{X}:\mathcal{T}\to\mathbb{R}^{+}$
\end_inset

 is a positive valued function that associates a firing rate with every
 transition,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathrm{I}:\mathcal{T}\to\mathbb{N}^{N}$
\end_inset

 associates an input vector with every transition,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathrm{O}:\mathcal{T}\to\mathbb{N}^{N}$
\end_inset

 associates an output vector with every transition,
\end_layout

\begin_layout Itemize
\begin_inset Formula $m$
\end_inset

 is a vector called 
\emph on
marking
\emph default
 which denotes the number of tokens 
\begin_inset Formula $m_{i}$
\end_inset

 placed in every place 
\begin_inset Formula $P_{i}$
\end_inset

.
 
\begin_inset Formula $m_{0}$
\end_inset

 is the initial marking.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To help analyse SPNs we define a fundamental structure called the 
\emph on
Building Blocks
\emph default
 or BBs, give an expression for its product-form solution and conditions
 required for its existence.
\end_layout

\begin_layout Subsubsection
Building blocks
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Definition 2.6.8
\end_layout

\begin_layout Plain Layout
A SPN 
\begin_inset Formula $S$
\end_inset

 with set of transitions 
\begin_inset Formula $\mathcal{T}$
\end_inset

 and set of 
\begin_inset Formula $N$
\end_inset

 places 
\begin_inset Formula $\mathcal{P}$
\end_inset

 is a 
\series bold
building block
\series default
 if it satisfies the following conditions:
\end_layout

\begin_layout Enumerate
For all 
\begin_inset Formula $T\in\mathcal{T}$
\end_inset

 then either 
\begin_inset Formula $T$
\end_inset

 is an output transition with 
\begin_inset Formula $O(T)=\emptyset$
\end_inset

 or 
\begin_inset Formula $T$
\end_inset

 is an input transition with 
\begin_inset Formula $I(T)=\emptyset$
\end_inset

.
\end_layout

\begin_layout Enumerate
For each 
\begin_inset Formula $T\in T_{I}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
(set of input transitions)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
, there exists 
\begin_inset Formula $T'\in T_{O}$
\end_inset

 (set of output transitions) such that 
\begin_inset Formula $O(T)=I(T')$
\end_inset

 and vice versa.
\end_layout

\begin_layout Enumerate
Two places 
\begin_inset Formula $P_{i},P_{j}\in\mathcal{P},\mbox{ }1\leq i,j\leq N,$
\end_inset

 are connected if there exists a transition 
\begin_inset Formula $T\in\mathcal{T}$
\end_inset

 such that the components 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 of 
\begin_inset Formula $I(T)$
\end_inset

 or of 
\begin_inset Formula $O(T)$
\end_inset

 are non-zero.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus condition 1 requires all transitions to be either input or output transitio
ns.
 Condition 2 required any input transition 
\begin_inset Formula $T_{y}$
\end_inset

 of the building block feeding a subset of places 
\begin_inset Formula $y$
\end_inset

 to have a corresponding output transition 
\begin_inset Formula $T_{y}'$
\end_inset

 that consumes the tokens from the same subset 
\begin_inset Formula $y$
\end_inset

.
 Finally condition 3 requires the SPN to be connected.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-BB-Simple"

\end_inset

 is an example of a building block with three places 
\begin_inset Formula $\mathcal{P}=\{P_{1},P_{2},P_{3}\}$
\end_inset

, three input transitions 
\begin_inset Formula $T_{I}=\{T_{12},T_{23},T_{3}\}$
\end_inset

 and three output transitions 
\begin_inset Formula $T_{O}=\{T_{12}',T_{23}',T_{3}'\}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/SimpleBB.svg
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example of a building block
\begin_inset CommandInset label
LatexCommand label
name "fig:Example-BB-Simple"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\series bold
Product form of building blocks
\end_layout

\begin_layout Standard
A product form result can be derived for an arbitrary building block using
 ERCAT and is detailed with proof in paper 
\begin_inset CommandInset citation
LatexCommand cite
key "SPNs"

\end_inset

.
 The paper thus derives a theorem for a product form result of an arbitrary
 building block, given below.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Theorem 2.6.3
\end_layout

\begin_layout Plain Layout
Consider a Building block 
\begin_inset Formula $S$
\end_inset

 with 
\begin_inset Formula $N$
\end_inset

 places and 
\begin_inset Formula $N\subseteq2^{{1,...,N}}\backslash\emptyset$
\end_inset

.
 Let 
\begin_inset Formula $\rho_{y}=\frac{\lambda_{y}}{\mu_{y}}$
\end_inset

 for 
\begin_inset Formula $T_{y},T_{y}'\in\mathcal{T},\mbox{ }|y|\geq1$
\end_inset

.
 If the following system of equations has a unique solution 
\begin_inset Formula $\rho_{i},\mbox{ }(1\leq i\leq N)$
\end_inset

:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\begin{cases}
\rho_{y}=\prod_{i\in y}\rho_{i} & \forall y\mbox{: }T_{y},T_{y}'\in\mathcal{T}\mbox{ }\wedge\mbox{ }|y|\geq1\\
\rho_{i}=\frac{\lambda_{i}}{\mu_{i}} & \forall i\mbox{ : }T_{i},T_{i}'\in\mathcal{T},\mbox{ }1\leq i\leq N
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
then the net’s balance equations – and hence stationary probabilities when
 they exist – have product-form solution:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\pi(m_{1},\mbox{ . . . },m_{N})\propto\prod_{i=1}^{N}\rho_{i}^{m_{i}}
\]

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please refer to paper 
\begin_inset CommandInset citation
LatexCommand cite
key "SPNs"

\end_inset

 for detailed proof of Theorem 2.6.3.
 Thus the conditions required for the building block in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-BB-Simple"

\end_inset

 in product form are 
\begin_inset Formula 
\[
\begin{cases}
\rho_{12}= & \rho_{1}\rho_{2}\\
\rho_{23}= & \rho_{2}\rho_{3}\\
\rho_{3}= & \frac{\lambda_{3}}{\mu_{3}}
\end{cases}
\]

\end_inset

 which gives the steady state probabilities and product form unconditionally
 as as: 
\begin_inset Formula 
\[
\pi(m_{1},m_{2},m_{3})\propto\left(\frac{\lambda_{12}\lambda_{3}\mu_{23}}{\mu_{12}\mu_{3}\lambda_{23}}\right)^{m_{1}}\left(\frac{\lambda_{23}\mu_{3}}{\mu_{23}\lambda_{3}}\right)^{m_{2}}\left(\frac{\lambda_{3}}{\mu_{3}}\right)^{m_{3}}
\]

\end_inset


\end_layout

\begin_layout Standard
From Theorem 2.6.3, the following corollary can be derived.
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Corollary 2.6.1
\end_layout

\begin_layout Plain Layout
Consider a Building block 
\begin_inset Formula $S$
\end_inset

 in product form as defined in Theorem 2.6.3, let 
\begin_inset Formula $T_{y}′\in T_{O}$
\end_inset

.
 The reversed rate of transition 
\begin_inset Formula $T_{y}′$
\end_inset

 is 
\begin_inset Formula $\lambda_{y}$
\end_inset

, which is the the rate of the corresponding input transition 
\begin_inset Formula $T_{y}$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
RCAT for Stochastic Petri Nets
\end_layout

\begin_layout Standard
We can specify many complex SPNs as a composition of multiple building blocks
 (BBs).
 Since the BBs themselves are in product form we can say that:
\end_layout

\begin_layout Enumerate
the reversed rates of the reversed actions corresponding to the output transitio
n firings are constant;
\end_layout

\begin_layout Enumerate
the input transitions are always enabled;
\end_layout

\begin_layout Enumerate
each state of the BB can be reached by the firing of any output transition.
\end_layout

\begin_layout Standard
This ensures that the three RCAT conditions hold and we can run Multiple
 Agent RCAT (
\begin_inset CommandInset citation
LatexCommand cite
key "RCAT2009Paper"

\end_inset

) on a composition of several BBs to find a product form for complex SPNs.
 
\end_layout

\begin_layout Subsubsection
Practical Example
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/SimpleSPN.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A simple SPN with two building blocks
\begin_inset CommandInset label
LatexCommand label
name "fig:simple-SPN-2BB"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simple-SPN-2BB"

\end_inset

 gives an example of a simple SPN composed of two building blocks.
 The dotted lines show the passive composition between the two building
 blocks.
 The output transitions 
\begin_inset Formula $T_{12}'\mbox{ and }T_{23}'$
\end_inset

 from one building block (
\begin_inset Formula $BB_{1}$
\end_inset

) corresponds with input transition 
\begin_inset Formula $T_{45}$
\end_inset

 of the second building block (
\begin_inset Formula $BB_{2}$
\end_inset

).
 Similarly, output transition 
\begin_inset Formula $T_{5}'$
\end_inset

 from 
\begin_inset Formula $BB_{2}$
\end_inset

 corresponds with input transition 
\begin_inset Formula $T_{23}$
\end_inset

 from 
\begin_inset Formula $BB_{1}$
\end_inset

.
 The conditions for 
\begin_inset Formula $BB_{1}$
\end_inset

 to be in product form are: 
\begin_inset Formula 
\[
\begin{cases}
\rho_{12}= & \rho_{1}\rho_{2}\\
\rho_{23}= & \rho_{2}\rho_{3}\\
\rho_{3}= & \frac{\lambda_{3}}{\mu_{3}}\\
\rho_{12}= & \frac{\lambda_{12}}{\mu_{12}}\\
\rho_{23}= & \frac{x_{23}}{\mu_{23}}
\end{cases}
\]

\end_inset

 where 
\begin_inset Formula $x_{23}$
\end_inset

 is the unknown rate for input transition 
\begin_inset Formula $T_{23}$
\end_inset

.
 Similarly the conditions for 
\begin_inset Formula $BB_{2}$
\end_inset

 to be in product form are:
\begin_inset Formula 
\[
\begin{cases}
\rho_{45}= & \rho_{4}\rho_{5}\\
\rho_{4}= & \frac{\lambda_{4}}{\mu_{4}}\\
\rho_{5}= & \frac{\lambda_{4}}{\mu_{4}}\\
\rho_{45}= & \frac{x_{45}}{\mu_{45}}
\end{cases}
\]

\end_inset

 where 
\begin_inset Formula $x_{45}$
\end_inset

 is the unknown rate for input transition 
\begin_inset Formula $T_{45}$
\end_inset

.
\end_layout

\begin_layout Standard
We then derive rate equations for unknowns 
\begin_inset Formula $x_{23}\mbox{ and }x_{45}$
\end_inset

 by applying RCAT and using corollary 2.6.1.
 Thus the rate equations are:
\begin_inset Formula 
\[
\begin{cases}
x_{45}= & \bar{\mu_{12}}+\bar{\mu}_{23}=\lambda_{12}+x_{23}\\
x_{23}= & \bar{\mu}_{5}=\lambda_{5}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Substituting the values into the rate equations the conditions for product
 form are:
\begin_inset Formula 
\[
\begin{cases}
(\lambda_{12}+\lambda_{5})\mu_{5}\mu_{4} & =\mu_{45}\lambda_{4}\lambda_{5}\\
\lambda_{5}\mu_{2}\mu_{3} & =\lambda_{2}\lambda_{3}\mu_{23}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
These conditions yield the product form solution:
\begin_inset Formula 
\[
\pi(m_{1},m_{2},m_{3},m_{4},m_{5})\propto\left(\frac{\lambda_{12}\lambda_{3}\mu_{23}}{\mu_{12}\mu_{3}\lambda_{5}}\right)^{m_{1}}\left(\frac{\lambda_{5}\mu_{3}}{\mu_{23}\lambda_{3}}\right)^{m_{2}}\left(\frac{\lambda_{3}}{\mu_{3}}\right)^{m_{3}}\left(\frac{\lambda_{4}}{\mu_{4}}\right)^{m_{4}}\left(\frac{\lambda_{5}}{\mu_{5}}\right)^{m_{5}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Implementation of the RCAT
\end_layout

\begin_layout Standard
This chapter covers the design, implementation and testing aspects of the
 RCAT implementation.
 Since RCAT was implemented from scratch, considerable effort was put in
 to produce easy and scalable application programming interface (API) and
 clean and modularised code.
 
\end_layout

\begin_layout Section
Design Decisions
\end_layout

\begin_layout Standard
The first design consideration was the API of the RCAT solver.
 The inputs to the RCAT algorithm (Theorem 2.6.1) are two PEPA compound agents
 synchronising over some action labels.
 Thus while considering the input to the automated version of RCAT, there
 were two choices:
\end_layout

\begin_layout Enumerate
User splits input requiring minimal automated parsing
\end_layout

\begin_layout Standard
In this possible implementation, the user is required to write PEPA processes
 such that they be can directly used in reversed rate calculation with minimal
 automated parsing.
 For example, a PEPA description, 
\begin_inset Formula $P_{n}=(e,\lambda).P_{n+1}(n\geq0)$
\end_inset

, can be converted to a process structure in MATLAB as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Bad-Input-example"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

p( 1 ).definition( 1, : ) = 
\end_layout

\begin_layout Plain Layout

{ `n', `e', `lambda', `n+1', `n>=0' } 
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
PEPA Process Description converted to MATLAB format
\begin_inset CommandInset label
LatexCommand label
name "fig:Bad-Input-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This option is thus easier to program but is non-intuitive and cumbersome
 to the user.
 The program would also be prone to calculation errors as we would not be
 able to robustly validate the input.
 An additional disadvantage would be coupling the API to close to the functional
 logic of RCAT.
 Finally it would also require the user to have some knowledge of the programmin
g language to supply a ready made PEPA structure as input as can be seen
 from the Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Bad-Input-example"

\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[2.]
\backslash
setcounter{enumi}{2}
\end_layout

\end_inset

User inputs Pure PEPA descriptions
\end_layout

\begin_layout Standard
In this implementation, the user inputs component descriptions as they would
 to a non-automated RCAT theorem (shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Func-to-run-rcat"

\end_inset

).
 This ensures ease of use and is quite intuitive for the user.
 It also deals with input validation and decoupling of the API from functional
 aspects of the RCAT theorem.
\end_layout

\begin_layout Standard
Option two was selected for its aforementioned advantages.
 In further detail, the API is simply a function 
\family typewriter
RCATscript
\family default
 which accepts the full PEPA description as text.
 For example, we write PEPA process description for the RCAT algorithm as
\begin_inset Formula 
\begin{eqnarray*}
\\
P_{n}= & (e,\lambda).P_{n+1} & (n\geq0)\\
P_{n}= & (a,\mu_{1}).P_{n-1} & (n>0)\\
Q_{n}= & (a,\top).Q_{n+1} & (n\geq0)\\
Q_{n}= & (d,\mu_{2}).Q_{n-1} & (n>0)\\
 & P_{0}\sync{a}Q_{0}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
This is an example of a queueing network (a basic tandem network with two
 nodes) modelled in PEPA.
 Its corresponding translation to code is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Process-Simple-Desc"

\end_inset

.
 Please note that the unspecified action rate 
\begin_inset Formula $\top$
\end_inset

 effectively has the value of 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $\infty$
\end_inset

, and is therefore represented as 
\emph on
infinity
\emph default
 in the program.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

P(n) = (e, lambda).P(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P(n) = (a, mu1).P(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

Q(n) = (a, infinity).Q(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

Q(n) = (d, mu2).Q(n+1) for n > 0
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Pure PEPA Process Description translated to RCAT Program input
\begin_inset CommandInset label
LatexCommand label
name "fig:PEPA-Process-Simple-Desc"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
From Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Process-Simple-Desc"

\end_inset

, it is apparent that with minimal substitution we can translate a pure
 PEPA process description to code input.
 RCAT also requires as input the cooperating agents (processes) with the
 actions they are synchronising on, which are converted into code input
 as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Coop-Input-eg"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

P(0) with Q(0) over {a}
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PEPA Cooperating Agents translated to RCAT Program input
\begin_inset CommandInset label
LatexCommand label
name "fig:PEPA-Coop-Input-eg"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $P(0)\mbox{ and }Q(0)$
\end_inset

 are the cooperating agents and 
\begin_inset Formula $\{a\}$
\end_inset

 is the set of synchronising actions.
 It is mandatory that the cooperation is written as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Coop-Input-eg"

\end_inset

 for parsing.
 
\end_layout

\begin_layout Subsubsection*
Running RCAT in MATLAB
\end_layout

\begin_layout Standard
The RCAT algorithm is run as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Func-to-run-rcat"

\end_inset

, with the converted PEPA process description (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Process-Simple-Desc"

\end_inset

) in a cell array as the first input and with PEPA cooperation string (see
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Coop-Input-eg"

\end_inset

) as second input.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

> input1 = { `P(n) = (e, lambda).P(n+1) for n >= 0',
\end_layout

\begin_layout Plain Layout

	`P(n) = (a, mu1).P(n-1) for n > 0',
\end_layout

\begin_layout Plain Layout

	`Q(n) = (a, infinity).Q(n+1) for n >= 0',
\end_layout

\begin_layout Plain Layout

	`Q(n) = (d, mu2).Q(n+1) for n > 0' }
\end_layout

\begin_layout Plain Layout

>
\end_layout

\begin_layout Plain Layout

> input2 = `P(0) with Q(0) over {a}'
\end_layout

\begin_layout Plain Layout

>
\end_layout

\begin_layout Plain Layout

> RCATscript( input1, input2 )
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Function used to run the RCAT Program
\begin_inset CommandInset label
LatexCommand label
name "fig:Func-to-run-rcat"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Choice of programming language
\end_layout

\begin_layout Standard
The next design consideration was the choice of programming language and
 effort was made to make a choice comfortable for both the developer and
 user and meeting the demands of the program.
 MATLAB was chosen as the implementation language for the project because
 of its capability to perform symbolic calculations as RCAT operates largely
 on symbolic variables.
 Its 
\emph on
Symbolic Math Toolbox
\emph default
 provides a large library of functions for symbolic variable instantiation,
 substitution, handling and operating on symbolic math expressions.
 Its greatest advantage is that programs can calculate in terms of symbolic
 variables giving a symbolic result.
 
\end_layout

\begin_layout Standard
Other languages considered were Python and Java.
 Python has a symbolic manipulation library called `
\emph on
sympy' 
\emph default
which is a lightweight normal Python module which aims to be a full-featured
 computer algebra system.
 MATLAB was chosen over Python as it is better tested and documented and
 because of its vast Library of functions.
 Java despite is object oriented capabilities was not chosen as a symbolic
 manipulator would have to be written from scratch and robustly tested thus
 making the task extremely time consuming.
\end_layout

\begin_layout Standard
Before starting implementation, we decided to break the RCAT Theorem into
 smaller implementation tasks.
 Since the project was not object oriented, we structured the system according
 to the implementation stages.
 These undermentioned implementation stages are based on the generic RCAT
 algorithm detailed in the background (Section 2.6.2).
\end_layout

\begin_layout Enumerate
Parsing PEPA input and constructing process structures 
\begin_inset Formula $P_{k}$
\end_inset

 and 
\begin_inset Formula $R_{k}$
\end_inset


\end_layout

\begin_layout Enumerate
Checking that RCAT conditions (1-3) hold for input PEPA model
\end_layout

\begin_layout Enumerate
Calculating reversed rates of passive actions
\end_layout

\begin_layout Enumerate
Replacing passive actions with symbolic reversed rates
\end_layout

\begin_layout Enumerate
Deducing the product-form solution of the model.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Parsing PEPA input
\end_layout

\begin_layout Standard
The initial step in implementing the project was parsing the PEPA input
 and converting it to the process structure 
\begin_inset Formula $P_{k}$
\end_inset

.
 On analysing a process description, we realised that a PEPA process definition
 can be broken into parts (or process descriptors) such as `name of the
 process', `source state of the transition', ` destination state of the
 transition', ` process action label', `action rate', and `process state
 domain'.
 For example, a process definition 
\begin_inset Formula $P_{n}=(e,\lambda).P_{n+1}(n\geq0)$
\end_inset

 has 
\begin_inset Formula $P$
\end_inset

 as the name of the process, 
\begin_inset Formula $n$
\end_inset

 as the state 
\begin_inset Formula $P$
\end_inset

 is currently in, 
\begin_inset Formula $n+1$
\end_inset

 as the the state 
\begin_inset Formula $P$
\end_inset

 is transitioning to, 
\begin_inset Formula $e$
\end_inset

 as its action label, 
\begin_inset Formula $\lambda$
\end_inset

 as it action rate and 
\begin_inset Formula $n\geq0$
\end_inset

 as the state domain.
 We thus parse this information from the process input by using regular
 expressions.
 
\end_layout

\begin_layout Standard
Thus the program 
\family typewriter
RCATscript
\family default
, on receiving input, a process description string (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Process-Simple-Desc"

\end_inset

), calls the function 
\family typewriter
registerProcess
\family default
 with one process description at a time.
 The program 
\family typewriter
registerProcess
\family default
 is responsible for parsing the process string and storing it in a map of
 processes, ordered by process name.
 Parsing is done using regular expressions as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-parsing-pepa-desc"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

matches = regexp( processDescription,
\end_layout

\begin_layout Plain Layout

`([A-Z][0-9]*)
\backslash
((.+)
\backslash
) = 
\backslash
((.+), (.+)
\backslash
)
\backslash
.([A-Z][0-9]*)
\backslash

\end_layout

\begin_layout Plain Layout

((.+)
\backslash
)(?: for )?(.*)', `tokens' );
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for parsing PEPA process description using regular expressions
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-parsing-pepa-desc"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The built in MATLAB 
\family typewriter
regexp
\family default
 function allows retrieving matched text from an input string, that corresponds
 to portions of the regular expression(s) enclosed in parentheses.
 In further detail, the regular expression 
\family typewriter
([A-Z][0-9]*)
\family default
 will match one letter in the upper case and zero or more numbers, thus
 allowing a process 
\begin_inset Formula $P$
\end_inset

 and a process 
\begin_inset Formula $P1$
\end_inset

 to both be parsed.
 Regexp 
\family typewriter

\backslash
((.+)
\backslash
)
\family default
 will ignore parentheses and match anything within them while 
\family typewriter
(?: for)?(.*)
\family default
 will optionally look for the keyword 
\family typewriter
for
\family default
 and optionally match anything after it.
 It thus gives the flexibility of having an optional state domain descriptor
 for a process.
\end_layout

\begin_layout Standard
Running the code in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-parsing-pepa-desc"

\end_inset

 on code input- 
\family typewriter
`P(n) = (e, lambda).P(n+1) for n >= 0'
\family default
, we ultimately get a list of aforementioned process descriptors - 
\family typewriter
{P, n, e, lambda, n+1, n>=0}
\family default
.
\end_layout

\begin_layout Subsubsection
Constructing 
\begin_inset Formula $P_{k}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $P_{k}$
\end_inset

 is a structure consisting of 
\begin_inset Formula $k$
\end_inset

 PEPA processes with their definitions.
 
\begin_inset Formula $k=1,2$
\end_inset

 is used in our initial system/network models used as input to RCAT, thus
 
\begin_inset Formula $P_{k}$
\end_inset

 will correspond to two separate PEPA processes analogous to P and Q respectivel
y in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Process-Simple-Desc"

\end_inset

.
\end_layout

\begin_layout Standard
Function 
\family typewriter
addToProcessStructure
\family default
 stores processes, ordered by process name, in a map called 
\emph on
registeredProcesses
\emph default
.
 So multiple descriptions of any process 
\begin_inset Formula $P$
\end_inset

 will be stored under the same key `P'.
 The map 
\family typewriter
registeredProcesses
\family default
 behaves as the 
\begin_inset Formula $P_{k}$
\end_inset

 for this implementation of RCAT.
\end_layout

\begin_layout Standard
A description of a process with name 
\begin_inset Formula $P$
\end_inset

 comprises of aforementioned process descriptors and is added to 
\family typewriter
registeredProcesses
\family default
 as a map with the process descriptors as keys.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ProcessDesc-map-KVset"

\end_inset

 lists the keyset which each process description map is ordered by.
 If a process 
\begin_inset Formula $P$
\end_inset

 has multiple descriptions (as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Process-Simple-Desc"

\end_inset

), they are converted into maps ordered by process descriptors and stored
 together in a cell array (a data structure in MATLAB which allows entries
 of different classes).
 Thus 
\family typewriter
registeredProcesses
\family default
 has a key-value pair : `process name'-`descriptions cell array'.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

keyset = { `transitionFromState',`actionName',`actionRate',
\end_layout

\begin_layout Plain Layout

`transitionToState',`domain' };
\end_layout

\begin_layout Plain Layout

valueset = { eval(processDefinition{2}), actionLabel, 
\end_layout

\begin_layout Plain Layout

actionRate, eval(processDefinition{6}), 
\end_layout

\begin_layout Plain Layout

[domainMin, domainMax] };
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Process description map's keyset and valueset
\begin_inset CommandInset label
LatexCommand label
name "fig:ProcessDesc-map-KVset"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Values of every process description ( as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ProcessDesc-map-KVset"

\end_inset

) have certain properties
\end_layout

\begin_layout Enumerate

\emph on
transitionFromState
\emph default
 is the source state the transition is coming from while 
\emph on
transitionToStat
\emph default
e is the destination state for that transition.
 They are stored as a MATLAB symbolic variables to simplify implementation
 stages such as RCAT condition checking (Section 3.2.4).
\end_layout

\begin_layout Enumerate

\emph on
actionName
\emph default
 is stored as a String
\end_layout

\begin_layout Enumerate

\emph on
actionRate
\emph default
 is stored as MATLAB symbolic variable as it is used extensively in reversed
 rate calculations (Section 3.2.2).
 
\end_layout

\begin_deeper
\begin_layout Enumerate
RCAT requires all passive action rates (rate 
\begin_inset Formula $=\top$
\end_inset

) to be relabelled to avoid confusion in multiple infinite action rates.
 We achieve this by relabelling all action rates with 
\emph on
`infinity'
\emph default
 to symbolic variable 
\emph on
`x'
\emph default
 postfixed with the action name of that passive rate.
 So a process with action rate 
\emph on
`infinity'
\emph default
 and action label 
\emph on
`a'
\emph default
 will be relabelled as 
\emph on
`x_a'
\emph default
.
 
\end_layout

\begin_layout Enumerate
Action rates are also parsed to check if they are mathematical expressions
 using function 
\family typewriter
stringToMatlabExpr.

\family default
 It parses a string, finds variables in the string, makes them symbolic
 and then returns the evaluated string as a symbolic variable which is stored
 as action rate.
 This requires action rates to compulsorily begin with an alphabet in the
 lower case and is validated by the same function.
 While evaluating the action rates, the program makes an assumption that
 no active action rate can have value `infinity' as this would cause the
 program to assume the action was passive when it was actually active.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
domain
\emph default
 is an equality or an inequality mathematical expression.
 This is analysed to give a range of values for which the state transition
 holds.
 The function 
\family typewriter
parseDomain
\family default
 achieves this by parsing the (in)equality string and returning a tuple
 of (
\emph on
domainMin
\emph default
, 
\emph on
domainMax
\emph default
), which denotes the maximum and minimum number of the range that process
 transition is valid for.
 We assume the state space for all 
\begin_inset Formula $R_{k}$
\end_inset

 to be 
\begin_inset Formula $[0,\infty]$
\end_inset

.
 Thus the maximum domain of a condition string 
\begin_inset Formula $n>0$
\end_inset

 will be 
\begin_inset Formula $\infty$
\end_inset

.
 But the maximum and minimum domain of a condition string 
\begin_inset Formula $n=0$
\end_inset

 will be evaluated as 
\begin_inset Formula $[0,0]$
\end_inset

.
 
\end_layout

\begin_layout Standard
The program 
\family typewriter
addToProcessStructure
\family default
 also stores all active action names and passive action names for each process
 in cell arrays and inserts them into maps 
\family typewriter
activeActionLabels
\family default
 and 
\family typewriter
passiveActionLabels
\family default
 respectively ordered by process name.
 This simplifies the task of creating the structure 
\begin_inset Formula $R_{k}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Constructing 
\begin_inset Formula $R_{k}$
\end_inset

 from 
\begin_inset Formula $P_{k}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R_{k}$
\end_inset

, similar to 
\begin_inset Formula $P_{k}$
\end_inset

, is structure consisting of 
\begin_inset Formula $k$
\end_inset

 PEPA processes where 
\begin_inset Formula $k=1,2$
\end_inset

.
 
\begin_inset Formula $R_{k}$
\end_inset

 in this implementation is modelled as a MATLAB structure array (an array
 with named fields that can contain data of varying types and sizes) called
 
\family typewriter
r
\family default
.
 Each entry in the structure 
\family typewriter
r
\family default
 contains fields for various properties of the processes which are populated
 using function 
\family typewriter
createRk
\family default
.
 The 
\family typewriter
definitions
\family default
 field refers to the parsed PEPA descriptions, the 
\family typewriter
activeLabels
\family default
 field refers the set of active actions for each 
\begin_inset Formula $P_{k}$
\end_inset

 and the 
\family typewriter
passiveLabels
\family default
 field refers the set of passive actions for each 
\begin_inset Formula $P_{k}$
\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Fields-in-rk"

\end_inset

 is an example of structure 
\family typewriter
r
\family default
 used to model two PEPA processes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

r = 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

1x2 struct array with fields:
\end_layout

\begin_layout Plain Layout

    definitions
\end_layout

\begin_layout Plain Layout

    activeLabels
\end_layout

\begin_layout Plain Layout

    passiveLabels
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fields in structure r containing r(1) and r(2)
\begin_inset CommandInset label
LatexCommand label
name "fig:Fields-in-rk"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
createRk
\family default
 is used for creating the structure 
\family typewriter
r
\family default
.
 It uses the maps 
\family typewriter
registeredProcesses, activeActionLabels
\family default
 and 
\family typewriter
passiveActionLabels
\family default
 that were generated in the function 
\family typewriter
addToProcessStructure
\family default
 and the process name (for example 
\begin_inset Formula $P$
\end_inset

) as the key to instantiate the three fields of the structure 
\family typewriter
r
\family default
 structure as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:createRk-populate-fields"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

for i = 1:numOfProcesses
\end_layout

\begin_layout Plain Layout

	r(i).definitions 
\end_layout

\begin_layout Plain Layout

	= registeredProcesses( processKeyset{1,i} );
\end_layout

\begin_layout Plain Layout

	r(i).activeLabels 
\end_layout

\begin_layout Plain Layout

	= setActionLabels(activeActionLabels,processKeyset{1,i});
\end_layout

\begin_layout Plain Layout

	r(i).passiveLabels 
\end_layout

\begin_layout Plain Layout

	= setActionLabels(passiveActionLabels,processKeyset{1,i});     
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Populating fields of structure 
\begin_inset Formula $R_{k}$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:createRk-populate-fields"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parsing PEPA cooperation
\end_layout

\begin_layout Standard
The function 
\family typewriter
registerCoop
\family default
 parses input for a PEPA cooperation (synchronisation) between two processes.
 A cooperation, as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Coop-Input-eg"

\end_inset

, is the second input to the API function 
\family typewriter
RCATscript
\family default
.
 The cooperation string is parsed using regular expressions as in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-parsing-pepa-coop"

\end_inset

.
 
\family typewriter
registerCoop
\family default
 returns the action labels the two processes are cooperating over in a cell
 array called 
\family typewriter
coopLabels
\family default
, which is used in calculating reversed rates and checking RCAT conditions.
 For input as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Coop-Input-eg"

\end_inset

, 
\family typewriter
coopLabels
\family default
 will equal 
\begin_inset Formula $\{a\mbox{ }\}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

matches = regexp( coopDescription,
\end_layout

\begin_layout Plain Layout

	`([A-Z][0-9]*)
\backslash
(([^
\backslash
)]+)
\backslash
) (with .+
\backslash
s*)+ over 
\backslash
{(.*)
\backslash
}', 
\end_layout

\begin_layout Plain Layout

	`tokens' );
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for parsing PEPA Cooperation string using regular expressions
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-parsing-pepa-coop"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Calculating Reversed Rates
\end_layout

\begin_layout Standard
Reversed rates of passive actions are calculated using the formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:GenericAlgoRRCal"

\end_inset

 stated in the generic algorithm (Section 2.6.2.3).
 The formula requires that the steady state probabilities 
\begin_inset Formula $\pi_{k}$
\end_inset

 are known for each 
\begin_inset Formula $k=1,2$
\end_inset

 in 
\begin_inset Formula $R_{k}$
\end_inset

 and requires 
\begin_inset Formula $r_{a}^{i}$
\end_inset

, the specified forward rate of action type 
\begin_inset Formula $a$
\end_inset

 going out of state 
\begin_inset Formula $i$
\end_inset

 (for the relevant 
\begin_inset Formula $k=1,2$
\end_inset

 in 
\begin_inset Formula $R_{k}$
\end_inset

) to be known.
 Thus the reversed rate calculation is divided into the undermentioned subsectio
ns.
\end_layout

\begin_layout Subsubsection
Calculating steady state probability
\end_layout

\begin_layout Standard
The RCAT application was primarily designed to run on systems composed of
 M/M/1 queues, which have known equilibrium probability distributions and
 are given by the formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:SSPD_of_MM1Q"

\end_inset

 stated in Section 2.3.2.
 The steady state distribution formula uses the utilisation 
\begin_inset Formula $\rho$
\end_inset

 of an M/M/1 queue which is defined as 
\begin_inset Formula 
\[
\rho_{i}=\frac{\lambda}{\mu}
\]

\end_inset

where 
\begin_inset Formula $\lambda$
\end_inset

 is the aggregate arrival rate at node 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $\mu$
\end_inset

 is the service rate of node 
\begin_inset Formula $i$
\end_inset

.
 Since it is assumed for all 
\begin_inset Formula $k=1,2$
\end_inset

, 
\begin_inset Formula $R_{k}$
\end_inset

 is a M/M/1 queue, 
\begin_inset Formula $\rho_{k}=\mbox{arrival rate of }R_{k}/\mbox{ service rate of }R_{k}$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Calculating total arrival and service rates for 
\begin_inset Formula $R_{k}$
\end_inset


\end_layout

\begin_layout Standard
The arrival rate (since 
\begin_inset Formula $R_{k}$
\end_inset

 is M/M/1) is equal to the sum of all rates for transitions from state 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $i+1$
\end_inset

 while the service rate is sum of all rates for transitions coming into
 state 
\begin_inset Formula $i$
\end_inset

, so from 
\begin_inset Formula $i+1$
\end_inset

 to 
\begin_inset Formula $i$
\end_inset

.
 The function used to find arrival and service rates 
\begin_inset Formula $\forall k$
\end_inset

 in 
\begin_inset Formula $R_{k}$
\end_inset

 is 
\family typewriter
getAggregateArrivalAndServiceRates
\family default
.
 The calculation involves iterating through all the definitions of a process
 and determining the the direction of the transition in each definition(see
 Figure 3.8).
 Function 
\family typewriter
isTransitioningForwards
\family default
 determines if a process transition is going out or coming into state 
\begin_inset Formula $i$
\end_inset

 using process descriptors 
\emph on
transitionFromState
\emph default
 and 
\emph on
transitionToState.

\emph default
 The arrival rate and service rate is the 
\family typewriter
forwardSum
\family default
 and 
\family typewriter
backwardSum
\family default
 respectively in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-calculating-arrival-service-rate"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

for definition = process.definitions
\end_layout

\begin_layout Plain Layout

   if isTransitioningForwards( definition )
\end_layout

\begin_layout Plain Layout

      forwardSum = forwardSum + definition(`actionRate');
\end_layout

\begin_layout Plain Layout

   else
\end_layout

\begin_layout Plain Layout

      backwardSum = backwardSum + definition(`actionRate');
\end_layout

\begin_layout Plain Layout

   end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for calculating arrival rate and service rate for each process
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-calculating-arrival-service-rate"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Function 
\family typewriter
sspdMM1
\family default
 calculates the steady state probability of an M/M/1 queue given an arrival
 and service rate.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

syms r x;
\end_layout

\begin_layout Plain Layout

rho = ( arrivalRate / serviceRate );
\end_layout

\begin_layout Plain Layout

formula = `(1 - r) * r^x';
\end_layout

\begin_layout Plain Layout

temp = subs( formula, x, state );
\end_layout

\begin_layout Plain Layout

sspd = subs( temp, r, rho );
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for SSPD calculation of M/M/1 queue
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-for-SSPD-calc"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The formula shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-for-SSPD-calc"

\end_inset

 is the formula for the equilibrium probability distribution (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:SSPD_of_MM1Q"

\end_inset

) of a M/M/1 queue.
 The MATLAB function 
\family typewriter
subs
\family default
 performs a symbolic variable substitution in a given mathematical expression,
 which in this case is the SSPD formula.
 On calculating 
\begin_inset Formula $\rho$
\end_inset

 (
\family typewriter
rho
\family default
) with arrival and service rate (both symbolic variables) and performing
 symbolic substitution in the formula for steady state probability, we get
 
\begin_inset Formula $\pi_{k}$
\end_inset

 for each 
\begin_inset Formula $k=1,2$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Calculating specified forward rate
\end_layout

\begin_layout Standard
Function 
\family typewriter
getStatesAndRateForAction
\family default
 calculates 
\begin_inset Formula $r_{a}^{i}$
\end_inset

, the specified forward rate of action type 
\begin_inset Formula $a$
\end_inset

 going out of state 
\begin_inset Formula $i$
\end_inset

 in the process where 
\begin_inset Formula $a$
\end_inset

 is the active action.
 Thus the function iterates over process definitions of 
\begin_inset Formula $P$
\end_inset

 as action 
\begin_inset Formula $a$
\end_inset

 belongs to the set of activeLabels in 
\begin_inset Formula $P$
\end_inset

 and returns the rate.
\end_layout

\begin_layout Subsubsection
Calculating reversed rates
\end_layout

\begin_layout Standard
Function 
\family typewriter
calculateReversedRate
\family default
 uses the formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:GenericAlgoRRCal"

\end_inset

 stated in the generic algorithm (Section 2.6.2.3) to calculate reversed rates
 for all passive synchronising actions.
 The code in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-reversed-rate-calc"

\end_inset

 corresponds to this, where the 
\family typewriter
forwardRate
\family default
 is the specified forward rate of a given active action, 
\family typewriter
iStateSSPD
\family default
 and 
\family typewriter
jStateSSPD
\family default
 is the steady state probability at state 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 respectively for some process 
\begin_inset Formula $P$
\end_inset

.
 As all three are MATLAB symbolic variables, the function 
\family typewriter
simplify
\family default
 reduces the formula which is a mathematical expression of the form 
\begin_inset Formula $\pi_{k}(i)r_{a}^{i}/\mbox{ }\pi_{k}(j)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

formula = (forwardRate * iStateSSPD) / jStateSSPD;
\end_layout

\begin_layout Plain Layout

reversedRate = simplify(formula);
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for reversed rate calculation
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-reversed-rate-calc"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Storing reversed rates
\end_layout

\begin_layout Standard
As a final step in reversed rate calculation, we need to store the reversed
 rate for each action 
\begin_inset Formula $a$
\end_inset

 that belongs to the set of cooperating actions, that is 
\begin_inset Formula $\forall a\in coopLabels$
\end_inset

.
 The function 
\family typewriter
storeReversedRates
\family default
 performs the task of storing reversed rates in a map called 
\family typewriter
reversedRates
\family default
 with each action in 
\family typewriter
coopLabels
\family default
 as the key.
 The map of reversed rates becomes significant while replacing the passive
 actions (
\begin_inset Formula $x_{a}$
\end_inset

) with the relevant reversed rates in 
\begin_inset Formula $R_{k}$
\end_inset

 and checks they are the same at each instance if there are multiple instances
 of the same action.
\end_layout

\begin_layout Subsection
Replacing Passive Actions with Reversed Rates 
\end_layout

\begin_layout Standard
In the structure 
\begin_inset Formula $R_{k}$
\end_inset

, all passive actions are represented in the form 
\family typewriter
x_a
\family default
 where 
\begin_inset Formula $a$
\end_inset

 is some passive action.
 These rates have to be replaced by the calculated reversed rates for all
 actions in the set of cooperating actions, that is 
\begin_inset Formula $\forall a\in coopLabels$
\end_inset

.
 We substitute symbolic solutions for each rate variable 
\begin_inset Formula $x_{a}$
\end_inset

 in 
\begin_inset Formula $R_{k}$
\end_inset

 in the function 
\family typewriter
setPassiveActionRate
\family default
 which matches the passive action rate with the right reversed rate and
 substitutes it in 
\begin_inset Formula $R_{k}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

if isequal( definition( `actionName' ), actionLabel )
\end_layout

\begin_layout Plain Layout

   oldActionRate = definition( `actionRate' );
\end_layout

\begin_layout Plain Layout

   definition( `actionRate' ) = reversedRates( actionLabel );
\end_layout

\begin_layout Plain Layout

   newActionRate = definition( `actionRate' );
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for substituting passive action rates
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-substituting-passive-act-rates"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
MATLAB is a pass by value language, thus when a function (modifying a structure
 field) returns, the caller function's copy of the structure is replaced
 by the functions copy such that only the modified field is replaced.
 This also means that MATLAB uses `copy-on-write', that is, variables are
 only copied if you modify them.
 This feature is used in function 
\family typewriter
setPassiveActionRate
\family default
 where assigning reversed rate (on Line 3 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-substituting-passive-act-rates"

\end_inset

) to variable 
\family typewriter
definition
\family default
, its value changes in the original structure 
\begin_inset Formula $R_{k}$
\end_inset

.
\end_layout

\begin_layout Subsection
Checking RCAT Conditions
\end_layout

\begin_layout Standard
The RCAT theorem has three conditions which need to be met for product form
 solution to exist for any system model.
 They are stated in Theorem 2.6.1.
 We have checked all three conditions in this implementation of RCAT.
 If any of the three conditions are violated, the program will exit with
 an exception error.
\end_layout

\begin_layout Subsubsection
Checking First Condition
\end_layout

\begin_layout Standard
RCAT first condition states that 
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
First Condition:
\series default
 Every passive action type in 
\begin_inset Formula $\mathcal{P}_{P}(L)$
\end_inset

 or 
\begin_inset Formula $\mathcal{P}_{Q}(L)$
\end_inset

 is always enabled in 
\begin_inset Formula $P$
\end_inset

 or 
\begin_inset Formula $Q$
\end_inset

 respectively.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The condition is to ensure that all passive actions 
\begin_inset Formula $a$
\end_inset

 are enabled in every state of the passive process for 
\begin_inset Formula $a$
\end_inset

.
 While constructing the structure 
\begin_inset Formula $R_{k}$
\end_inset

, we store the passive actions or the set 
\begin_inset Formula $\mathcal{P}_{P}(L)$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

 is some process, in the field 
\family typewriter
passiveLabels
\family default
 of structure 
\family typewriter
r
\family default
.
 The function 
\family typewriter
checkFirstRcatCondition
\family default
 iterates through all 
\family typewriter
passiveLabels
\family default
 for all 
\begin_inset Formula $R_{k},k=1,2$
\end_inset

 and ensures that all passive actions are enabled.
 The function 
\family typewriter
checkActionIsEnabled
\family default
 checks if action is enabled in all states of a process transition graph
 for all descriptors of 
\begin_inset Formula $R_{k}$
\end_inset

.
 
\end_layout

\begin_layout Standard
It is assumed that the state space of any process is from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $\infty$
\end_inset

.
 This assumption is made to perform the condition checks on the whole state
 space of a process, but the assumptions are intuitively reasonable as (mostly
 for this implementation) the input is networks formed of M/M/1 queues.
 Despite this assumption, it will be relatively straightforward to extend
 the function due to decoupling of concerns.
 Furthermore, even in a closed network the number in a queue is unbounded
 since it depends on the (given) initial network population 
\begin_inset Formula $N$
\end_inset

.
 
\begin_inset Formula $N$
\end_inset

 would only ever be needed to calculate the normalising constant which is
 out of scope of this project.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

if ~isequal( definition( `domain' ), stateSpace )
\end_layout

\begin_layout Plain Layout

    if allChecksAreOK( definition, allDefs )
\end_layout

\begin_layout Plain Layout

       isEnabled = true;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

    isEnabled = true;
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for Checking First Condition
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-Checking-1st-cond"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Function 
\family typewriter
checkActionIsEnabled
\family default
 (code snippet in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-Checking-1st-cond"

\end_inset

) compares the 
\emph on
domain
\emph default
 of the passive process which has the passive transition with the state
 space of all processes in 
\begin_inset Formula $R_{k}$
\end_inset

.
 As mentioned before the state space is assumed to be 
\begin_inset Formula $[0,\infty]$
\end_inset

.
 If the domain equals the state space, then it is trivial that the action
 is enabled throughout the process transition graph.
 If not, function 
\family typewriter
allChecksAreOK
\family default
 evaluates the domain of the process further.
 This helper function considers two cases:
\end_layout

\begin_layout Enumerate
when there is a passive transition going from 
\begin_inset Formula $n\to n+1$
\end_inset


\end_layout

\begin_layout Standard
If a process has a transition 
\begin_inset Formula $n\to n+1$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the current state, then for an action to always be enabled, the process
 description needs a domain of 
\begin_inset Formula $[0,\infty]$
\end_inset

 (that is equal to state space).
 If not, the first condition will be violated.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[2.]
\backslash
setcounter{enumi}{2}
\end_layout

\end_inset

when there is a passive transition going from 
\begin_inset Formula $n\to n-1$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

if isequal( domain(1), 1 )
\end_layout

\begin_layout Plain Layout

   if isSymbolicEqual( transitionTostate, eval(`n-1') )
\end_layout

\begin_layout Plain Layout

      if hasInvisibleTransition( allDefs, definition )
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for Checking First Condition
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-Checking-ist-cond-other"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If a process has a transition 
\begin_inset Formula $n\to n-1$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the current state, the process description will have a domain of 
\begin_inset Formula $[1,\infty]$
\end_inset

 because of condition string 
\begin_inset Formula $n>0$
\end_inset

 (checked in Line 1 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-Checking-ist-cond-other"

\end_inset

).
 For an action to be enabled, an additional `invisible' transition is required
 going from 
\begin_inset Formula $n\to n$
\end_inset

 where 
\begin_inset Formula $n=0$
\end_inset

.
 Function 
\family typewriter
hasInvisibleTransition
\family default
 checks for invisible transitions.
 If all conditions are satisfied, the function notifies the user that the
 First condition has been satisfied (as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:output-for-condition-checks"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

>> RCATscript(x2, y2)
\end_layout

\begin_layout Plain Layout

First condition of RCAT is satisfied.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Second condition of RCAT is satisfied.
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Snippet of output of program RCATscript
\begin_inset CommandInset label
LatexCommand label
name "fig:output-for-condition-checks"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Checking Second Condition
\end_layout

\begin_layout Standard
RCAT second condition states that 
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Second Condition:
\series default
 Every reversed action of an active action type in 
\begin_inset Formula $\mathcal{A}{}_{P}(L)$
\end_inset

 or 
\begin_inset Formula $\mathcal{A}{}_{Q}(L)$
\end_inset

 is always enabled in 
\begin_inset Formula $\overline{P}$
\end_inset

 or 
\begin_inset Formula $\overline{Q}$
\end_inset

 respectively.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This condition checks if there is an incoming active action 
\begin_inset Formula $a$
\end_inset

 in every state of the active process for 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $\forall a\in coopLabels$
\end_inset

.
 The rationale is very similar to the first condition.
 The function 
\family typewriter
checkSecondRcatCondition
\family default
 iterates through all 
\family typewriter
activeLabels
\family default
 for all 
\begin_inset Formula $R_{k},k=1,2$
\end_inset

 and using 
\family typewriter
checkForIncomingTransitions
\family default
 function checks to see if there is an incoming active action 
\begin_inset Formula $a$
\end_inset

 in every state of the active process for 
\begin_inset Formula $a$
\end_inset

.
 On further analysing, it is apparent that 
\emph on
incoming
\emph default
 
\emph on
transitions
\emph default
 refer to transitions going from state 
\begin_inset Formula $n\to n-1$
\end_inset

.
 This assures that every state 
\begin_inset Formula $n$
\end_inset

 will have an incoming transition for the state space which is assumed to
 be 
\begin_inset Formula $[0,\infty]$
\end_inset

 for all processes in 
\begin_inset Formula $R_{k}$
\end_inset

 (since we are primarily dealing with MM1 queues).
 The 
\emph on
domain
\emph default
 for these transitions is calculated as 
\begin_inset Formula $[1,Inf]$
\end_inset

 and is checked in the function as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-checking-incoming-trans"

\end_inset

 (line 1).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

if isequal( domain(1), 1 ) && isequal( domain(2), Inf )
\end_layout

\begin_layout Plain Layout

   if isSymbolicEqual( transitionTostate, eval(`n-1') ) &&
\end_layout

\begin_layout Plain Layout

   isSymbolicEqual( transitionFromState, eval(`n') )
\end_layout

\begin_layout Plain Layout

       isEnabled = true;
\end_layout

\begin_layout Plain Layout

   end
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code for checking incoming transitions
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-checking-incoming-trans"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
isSymbolicEqual
\family default
(Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-checking-symbolic-equal"

\end_inset

) checks if the states 
\emph on
from
\emph default
 and 
\emph on
to
\emph default
 are equal to 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $n-1$
\end_inset

.
 Finally if all conditions are satisfied, the function notifies the user
 that the second condition has been satisfied (as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:output-for-condition-checks"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Checking Third Condition
\end_layout

\begin_layout Standard
RCAT third condition states that 
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\series bold
Third Condition:
\series default
 Every occurrence of a reversed action of an active action type in 
\begin_inset Formula $\mathcal{A}{}_{P}(L)$
\end_inset

 or 
\begin_inset Formula $\mathcal{A}{}_{Q}(L)$
\end_inset

 has the same rate in 
\begin_inset Formula $\overline{P}$
\end_inset

 or 
\begin_inset Formula $\overline{Q}$
\end_inset

 respectively.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This condition checks that the total reversed rate of all incoming active
 actions 
\begin_inset Formula $a$
\end_inset

 in state 
\begin_inset Formula $k$
\end_inset

 of the active process is equal to a constant 
\begin_inset Formula $\bar{r_{a}}$
\end_inset

 independent of state 
\begin_inset Formula $k$
\end_inset

.
 It is known that for M/M/1 queues, the equilibrium state probabilities
 are state independent.
 Thus the reversed rate is same for all the states the transition corresponds
 to as the ratio of 
\begin_inset Formula $\pi(n+1)/\pi(n)$
\end_inset

 (used in rate equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:GenericAlgoRRCal"

\end_inset

) is constant.
\end_layout

\begin_layout Standard
We then need to check if there are multiple transitions with the same action
 name in the description of the active process, calculate their reversed
 rates and ensure they are equal.
 Thus if active process 
\begin_inset Formula $P$
\end_inset

 has multiple transitions for action type 
\begin_inset Formula $a$
\end_inset

, their reversed rates will be calculated and checked to see if they are
 equal.
 The function 
\family typewriter
checkThirdRcatCondition
\family default
 iterates over all 
\begin_inset Formula $activeLabels$
\end_inset

 for all active processes and checks if action 
\begin_inset Formula $a$
\end_inset

 has multiple transitions, 
\begin_inset Formula $\forall a\in coopLabels\mbox{ }\&\mbox{ }a\in activeLabels$
\end_inset

.
 Then its reversed rates are calculated and are checked for equality with
 function 
\family typewriter
isSymbolicEqual
\family default
.
 The function checks to see if the difference (Line 2, Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-checking-symbolic-equal"

\end_inset

) between two symbolic variables is zero, proving they are equal.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

function ret = isSymbolicEqual( s1, s2 )
\end_layout

\begin_layout Plain Layout

    ret = ( simplify( s1 - s2 ) == 0 );
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code to checking symbolic equivalence
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-checking-symbolic-equal"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally if all requirements are satisfied, the function notifies the user
 of satisfying the third condition and concludes RCAT condition checking.
\end_layout

\begin_layout Subsection
Generating a Product Form Result
\end_layout

\begin_layout Standard
All 
\begin_inset Formula $R_{k}\mbox{ }(k\geq2)$
\end_inset

 agents to RCAT are M/M/1 queues with 
\begin_inset Formula $\rho_{k}=\frac{\mbox{arrival rate of }R_{k}}{\mbox{ service rate of }R_{k}}$
\end_inset

.
 Hence the unnormalised equilibrium probability for state 
\begin_inset Formula $i_{k}$
\end_inset

 in the process 
\begin_inset Formula $R_{k}$
\end_inset

 is 
\begin_inset Formula $\left(\rho_{k}\right)^{i_{k}}$
\end_inset

 .
 From this we can derive the product form result using the Jackson’s theorem
 :
\begin_inset Formula 
\[
\pi(m_{1},\mbox{ . . . , }m_{N})\propto\prod_{i=1}^{N}\rho_{k}^{i_{k}}
\]

\end_inset

The RCAT implementation prints a system of rate equations as output by retrievin
g them from structure 
\begin_inset Formula $R_{k}$
\end_inset

 as a part of the implementation stage `Replacing Passive Actions with Reversed
 Rates'.
 This system of rate equations is solved and their values are replaced in
 
\begin_inset Formula $\rho_{k}$
\end_inset

 to generate the aforementioned product form result.
 Thus for instance if we derive the rate equation - `
\begin_inset Formula $x_{a}=\lambda$
\end_inset

', we replace the value of unknown action rate 
\begin_inset Formula $x_{a}$
\end_inset

 of action 
\begin_inset Formula $a$
\end_inset

 with 
\begin_inset Formula $\lambda$
\end_inset

 and use the new value while generating the product form result.
 We can use MATLAB functions 
\family typewriter
solve
\family default
 to evaluate solutions to a system of rate equations.
 
\end_layout

\begin_layout Standard
For example, the equations in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Solving-system-of-rateEqns"

\end_inset

 need to be evaluated as they have unknowns in their solutions (lines 2-3).
 The MATLAB library function 
\family typewriter
solve
\family default
 finds a solution for both x_a1 and x_a2 as shown in lines 9 - 15.
 Before using the function 
\family typewriter
solve
\family default
, all variables must be declared symbolic using function 
\family typewriter
syms
\family default
 as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Solving-system-of-rateEqns"

\end_inset

 on line 7.
 Thus evaluating rate equations, displayed by the software, is left to the
 user as it is a straightforward process.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

> RCATscript(x2, y2)
\end_layout

\begin_layout Plain Layout

  Printing passive action rates...
\end_layout

\begin_layout Plain Layout

  Reversed rate for passive action a1: 
\end_layout

\begin_layout Plain Layout

  x_a1 = p21*(lambda2 + x_a2)
\end_layout

\begin_layout Plain Layout

  Reversed rate for passive action a2: 
\end_layout

\begin_layout Plain Layout

  x_a2 = p12*(lambda1 + x_a1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> syms x_a1 x_a2 p21 lambda2 p12 lambda1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> solve(`x_a1 = p21*(lambda2 + x_a2)', 
\end_layout

\begin_layout Plain Layout

        `x_a2 = p12*(lambda1 + x_a1)' ) 
\end_layout

\begin_layout Plain Layout

  ans = x_a1: [1x1 sym]
\end_layout

\begin_layout Plain Layout

        x_a2: [1x1 sym]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> x_a1 = -(p21*(lambda2 + lambda1*p12))/(p12*p21 - 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> x_a2 = -(lambda1*p12 + lambda2*p12*p21)/(p12*p21 - 1)
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Solving system of rate equations
\begin_inset CommandInset label
LatexCommand label
name "fig:Solving-system-of-rateEqns"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In some cases, the rate equations are non-linear.
 To solve non-linear system of equations, we can use MATLAB Library function
 
\family typewriter
fsolve
\family default
.
 It checks if the equations converge to a single value and has the option
 of running multiple iterations with guessed values.
 Another alternative is to use `fixed point iteration', but this has not
 been implemented as a part of this project.
\end_layout

\begin_layout Section
Testing and Verification
\end_layout

\begin_layout Standard
Testing and verification of program logic and output are important aspects
 of the implementation process as they help in ensuring a robust and correct
 program.
 The program logic was unit tested using MATLAB unit test library 
\emph on
xUnit
\emph default
.
 The implementation of different parts of the program logic is in different
 files making it quite easy to be unit tested.
 All tests follow a similar format where we compare the results of the function
 being tested with the expected values.
 
\emph on
xUnit
\emph default
 provides functions to test exceptions and equality.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

assertEqual( reversedRates.length(), 1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

assertTrue( isequal( reversedRates( `a' ), lambda ) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

assertExceptionThrown(@()storeReversedRates(coopLabels,r),
\end_layout

\begin_layout Plain Layout

`RCATscript:InvalidComputationStoreReversedRates' );
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Code snippet for a Test
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-for-test"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-for-test"

\end_inset

 is a code snippet from a test 
\family typewriter
`testStoreReversedRates'
\family default
 which tests if reversed rates are calculated and stored correctly.
 
\emph on
xUnit
\emph default
 provides a function 
\family typewriter
assertExceptionThrown
\family default
 to test if the program throws the right exception on being given erroneous
 input (as shown on lines 5-6 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-for-test"

\end_inset

).
 This function is very useful for testing program validations.
 Please refer to Appendix for additional test cases and instructions to
 run the unit tests.
\end_layout

\begin_layout Standard
Program output is verified by running RCAT on various system models, taken
 from research papers and provided by the supervisor, and comparing the
 solutions against the given solutions.
 The implementation has a command line interface which has been tested by
 the user.
 User testing by primarily myself and my supervisor has helped correct any
 erroneous or unexpected behaviour by the program.
\end_layout

\begin_layout Standard
This concludes the implementation of RCAT.
 The next chapter details the implementation of running RCAT on multiple
 compound agents and Stochastic Petri Nets.
\end_layout

\begin_layout Chapter
Implementation of MARCAT and RCAT for SPNs and PITs
\end_layout

\begin_layout Standard
This chapter covers the implementation of MARCAT, an extension of RCAT and
 the design and implementation of RCAT for Stochastic Petri Nets (SPNs).
 It also delineates Propagation of Instantaneous Transitions (PITs) and
 provides an implementation design for running RCAT on PITs.
 
\end_layout

\begin_layout Section
Multiple Agents RCAT
\end_layout

\begin_layout Standard
The Reversed Compound Agent Theorem (RCAT) is used to derive the reversed
 process of a cooperation between two agents.
 RCAT can be generalised to a cooperation of multiple agents.
 This generalised theorem is referred to as the MARCAT or Multiple Agents
 RCAT.
 The theorem is detailed in paper 
\begin_inset CommandInset citation
LatexCommand cite
key "RCAT2009Paper"

\end_inset

.
\end_layout

\begin_layout Standard
To implement MARCAT, we extended the current implementation of RCAT.
 Due to the scalable design of the software, extending the implementation
 was a straightforward process.
\end_layout

\begin_layout Subsection
Parsing User Input
\end_layout

\begin_layout Standard
The API for this implementation has been maintained as the 
\family typewriter
RCATscript
\family default
, a function with two inputs - a list of PEPA process descriptions and the
 names cooperating processes.
 This is detailed in section 3.2.1 of this report.
 Since the first input is a list of process descriptions, this list has
 been simply extended to include 
\begin_inset Formula $k>2$
\end_inset

 number of agents.
 No changes have been made to the syntax of specifying an agent as input.
 Processes are parsed to generate the structure 
\begin_inset Formula $R_{k}$
\end_inset

 in the function 
\family typewriter
registerProcess
\family default
.
 Since the function parses the process string and stores it in a map of
 processes ordered by process name, no extensions were required to ensure
 it worked for multiple processes.
 As shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-to-register-MA"

\end_inset

, we iterate over the processes 
\begin_inset Formula $P_{k}$
\end_inset

 given as input and register them using the 
\family typewriter
registerProcess
\family default
 function.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

for i = 1:length( processList )
\end_layout

\begin_layout Plain Layout

process = processList(i);
\end_layout

\begin_layout Plain Layout

registerProcess( registeredProcesses, activeActionLabels,...
             
\end_layout

\begin_layout Plain Layout

passiveActionLabels, process{1} );
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Code to register multiple agents
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-to-register-MA"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Creating 
\begin_inset Formula $R_{k}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R_{k}$
\end_inset

, as in the aforementioned implementation of RCAT, is a structure consisting
 of 
\begin_inset Formula $k$
\end_inset

 PEPA processes where 
\begin_inset Formula $k\geq2$
\end_inset

.
 It is modelled as a MATLAB 
\emph on
struct
\emph default
 with fields as mentioned in section 3.2.1.2.
 To accommodate multiple agents the function createRk was extended to iterate
 over all the processes in the map of registered processes as opposed to
 having a fixed size of 2.
 This is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-createrk-ma"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

for i = 1:numOfProcesses 
\end_layout

\begin_layout Plain Layout

	r(i).definitions = registeredProcesses(processKeyset{1,i})
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Code for creating 
\begin_inset Formula $R_{k}$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Code-createrk-ma"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Parsing PEPA cooperation
\end_layout

\begin_layout Standard
Since MARCAT is the cooperation of multiple agents, the second input to
 
\family typewriter
RCATscript
\family default
 has been changed to include the multiple agents.
 This does not affect the aforementioned method of running the RCAT solver
 or specifying cooperation between two agents.
 We specify cooperation 
\begin_inset Formula $\ensuremath{\sync{L}}P_{k},\mbox{ }k\geq2$
\end_inset

 as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Coop-String-3agents"

\end_inset

.
 It specifies a cooperation string between three processes P1, P2 and P3.
 Keyword `with' is used as the cooperation symbol.
 The actions which processes cooperate over are stated in parentheses.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

`P1(0) with P2(0) with P3(0) over {a1, a2, a3}'
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Cooperation String for Three agents
\begin_inset CommandInset label
LatexCommand label
name "fig:Coop-String-3agents"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To parse the cooperation string, function 
\family typewriter
registerCoop
\family default
 had to be extended.
 Parsing the cooperation string is achieved using regular expressions as
 shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Code-Parsing-coop-3agents"

\end_inset

.
 String `([A-Z][0-9]*)
\backslash
 (([^
\backslash
)]+)
\backslash
)' matches a single occurrence of process P1(0).
 Regular expression `(with .+
\backslash
s*)+' will match multiple occurrences of a string beginning with the keyword
 `with'.
 This is then parsed to divide the string into the names of the processes
 and the list of cooperating action labels in the same way as mentioned
 in section 3.2.1.3.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

matches = regexp( coopDescription, ...
         
\end_layout

\begin_layout Plain Layout

`([A-Z][0-9]*)
\backslash
(([^
\backslash
)]+)
\backslash
) (with .+
\backslash
s*)+ over 
\backslash
{(.*)
\backslash
}',
\end_layout

\begin_layout Plain Layout

`tokens' );     
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Code for Parsing Cooperation String
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-Parsing-coop-3agents"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The implementation for calculating reversed rates and checking RCAT conditions
 is the same as mentioned in the previous chapter.
 We can use the rate equations generated to construct the product form result
 using the same method as detailed in section 3.2.5.
\end_layout

\begin_layout Section
Generating Product-Form Solutions for Stochastic Petri Nets
\end_layout

\begin_layout Standard
Stochastic Petri Nets (SPNs), as mentioned in the section 2.6.3, are different
 from Stochastic Process Algebra like PEPA and thus cannot be directly input
 into the RCAT solver.
 We generate product-form solutions for SPNs by applying MARCAT on a model
 consisting of several SPN building blocks.
 For a practical example, please refer to the background.
\end_layout

\begin_layout Subsection
Formalising Stochastic Petri Nets
\end_layout

\begin_layout Standard
Our first concern while implementing this extension was designing a formalism
 for SPN building blocks.
 Due to the graph like structure of SPNs, it is difficult to formalise them
 using a Markovian Process Algebra like PEPA.
 So a new formalism was designed which treats a subset of SPNs as a connection
 of building blocks.
\end_layout

\begin_layout Subsubsection
Formalising building blocks
\end_layout

\begin_layout Standard
A building block as defined in 
\emph on
Definition 2.6.8
\emph default
 is an SPN 
\begin_inset Formula $S$
\end_inset

 with set of transitions 
\begin_inset Formula $\mathcal{T}$
\end_inset

 and set of 
\begin_inset Formula $N$
\end_inset

 places 
\begin_inset Formula $\mathcal{P}$
\end_inset

 where 
\begin_inset Formula $\mathcal{T}$
\end_inset

 can be broken into set 
\begin_inset Formula $T_{I}$
\end_inset

 of input transitions and set 
\begin_inset Formula $T_{O}$
\end_inset

 of output transitions.
 So we defined a building block as a MATLAB 
\emph on
struct
\emph default
 as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Building-Block-formalism"

\end_inset

 with three properties:
\end_layout

\begin_layout Enumerate

\emph on
places
\emph default
: This is a set of 
\begin_inset Formula $N$
\end_inset

 places of a building block stored as a cell array of strings.
\end_layout

\begin_layout Enumerate

\emph on
inputs:
\emph default
 This is the set 
\begin_inset Formula $T_{I}$
\end_inset

 of input transitions, that is stored as a map with the transition name
 as the key and the transition firing rate as the value.
\end_layout

\begin_layout Enumerate

\emph on
outputs:
\emph default
 This is the set 
\begin_inset Formula $T_{O}$
\end_inset

 of output transitions, that is stored as a map with the transition name
 as the key and the transition firing rate as the value.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

1x1 struct array with fields:         
\end_layout

\begin_layout Plain Layout

	places: {`P1'  `P2'  `P3'}      
\end_layout

\begin_layout Plain Layout

	inputs: [3x1 containers.Map]     
\end_layout

\begin_layout Plain Layout

	outputs: [3x1 containers.Map]
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Building Block formalism as a MATLAB struct
\begin_inset CommandInset label
LatexCommand label
name "fig:Building-Block-formalism"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Specifying Building blocks as input
\end_layout

\begin_layout Standard
On determining a way for formalising the building block, we then dealt with
 converting a structural building block into a programmable input and parsing
 it to construct the building block 
\emph on
struct
\emph default
.
 This is best explained using an example.
 Let us take the simple building block of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simpleBB"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/SimpleBB.svg
	scale 80

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Example of a building block 
\begin_inset CommandInset label
LatexCommand label
name "fig:simpleBB"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It has three places 
\begin_inset Formula $\{P_{1},P_{2},P_{3}\}$
\end_inset

 with input transitions 
\begin_inset Formula $\{T_{12},T_{23},T_{3}\}$
\end_inset

 and output transitions 
\begin_inset Formula $\{T_{12}',T_{23}',T_{3}'\}$
\end_inset

.
 Let the rates of the three input transitions be 
\begin_inset Formula $\{\lambda_{12},\infty,\lambda_{3}\}$
\end_inset

 and the rates of output transitions be 
\begin_inset Formula $\{\mu_{12},\mu_{23},\mu_{3}\}$
\end_inset

.
 Rate 
\begin_inset Formula $\infty$
\end_inset

 denotes that the firing of an output transition of some building block
 corresponds to the firing of the transition with rate 
\begin_inset Formula $\infty$
\end_inset

.
 The user specifies this information as input to the program 
\family typewriter
RCATscriptForSPN 
\family default
as the string shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Building-Block-ip-by-user"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

`{P1, P2, P3}, {i_t12, i_t23, i_t3}, 
\end_layout

\begin_layout Plain Layout

 {lambda12, infinity, lambda3}, 
\end_layout

\begin_layout Plain Layout

 {o_t12, o_t23, o_t3}, {mu12, mu23, mu3}'
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Building Block as input by user
\begin_inset CommandInset label
LatexCommand label
name "fig:Building-Block-ip-by-user"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is important to note that all input transitions are prefixed by `i' while
 all output transitions are prefixed by `o'.
 This helps the program ensure that every input transition has a corresponding
 output transition, as it is one of the mandatory conditions for an SPN
 to be a building block.
 The string is always arranged in the order as shown in the Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Building-Block-ip-by-user"

\end_inset

, starting with places followed by input transitions, input transition rates,
 output transitions and output transition rates.
\end_layout

\begin_layout Subsubsection
Specifying Building Block connections
\end_layout

\begin_layout Standard
Since an SPN is specified as a model composed with several connected building
 blocks, the user inputs the several building blocks as a list to the program
 
\family typewriter
RCATscriptForSPN
\family default
.
 The user also has to input a routing probability matrix giving the connections
 between the different building blocks and their routing probabilities.
 The Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simpleSPN2BBs"

\end_inset

 gives an example of a simple SPN composed of two building blocks.
 The dotted lines show the passive composition between the two building
 blocks.
 So the firing of transitions 
\begin_inset Formula $T_{12}'\mbox{ and }T_{23}'$
\end_inset

 from one building block (BB1) corresponds with input transition 
\begin_inset Formula $T_{45}$
\end_inset

 of the other building block (BB2).
 Similarly, output transition 
\begin_inset Formula $T_{5}'$
\end_inset

 from BB2 corresponds with input transition 
\begin_inset Formula $T_{23}$
\end_inset

 of BB1.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/SimpleSPN.svg
	scale 55

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Example of a SPN with two building blocks
\begin_inset CommandInset label
LatexCommand label
name "fig:simpleSPN2BBs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The passive cooperations between the building blocks are specified as shown
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:User-input-bb-connections"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

`{o_t12 = 1, o_t23 = 1 to i_t45} ; {o_t5 = 1 to i_t23}'
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
User input specifying passive compositions between BBs
\begin_inset CommandInset label
LatexCommand label
name "fig:User-input-bb-connections"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each connection is stated by the user in parentheses 
\begin_inset Formula $\{...\}$
\end_inset

 separated by a semi-colon as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:User-input-bb-connections"

\end_inset

.
 Connection `
\family typewriter
o_t12 = 1, o_t23 = 1 to i_t45
\family default
' states that output transitions 
\begin_inset Formula $t12\mbox{ and }t23$
\end_inset

 correspond to input transition 
\begin_inset Formula $t45$
\end_inset

 with routing probability equal to 1.
 This routing probability is used while calculating rate equations.
 The routing probability becomes significant while looking at the behaviour
 of the BB.
 It the routing probability were 
\begin_inset Formula $p$
\end_inset

 then the output transition has a chance of synchronising with its corresponding
 input transition with probability 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Running RCAT for SPNs
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

listOfBBs = {
\end_layout

\begin_layout Plain Layout

`{P1, P2, P3}, {i_t12, i_t23, i_t3}, 
\end_layout

\begin_layout Plain Layout

 {lambda12, infinity, lambda3},
\end_layout

\begin_layout Plain Layout

 {o_t12, o_t23, o_t3}, {mu12, mu23, mu3}',
\end_layout

\begin_layout Plain Layout

`{P4, P5}, {i_t4, i_t45, i_t5}, 
\end_layout

\begin_layout Plain Layout

 {lambda4, infinity, lambda5}, 
\end_layout

\begin_layout Plain Layout

 {o_t4, o_t45, o_t5}, {mu4, mu45, mu5}'}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

connectionString =
\end_layout

\begin_layout Plain Layout

`{o_t12 = 1, o_t23 = 1 to i_t45} ; {o_t5 = 1 to i_t23}'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

RCATscriptForSPN( listOfBBs, connectionString )
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Running RCAT on a SPN with two building blocks
\begin_inset CommandInset label
LatexCommand label
name "fig:Running-RCAT-2BBSPN"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Running-RCAT-2BBSPN"

\end_inset

 shows how the input is specified for a SPN model (of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simpleSPN2BBs"

\end_inset

) using lists of building blocks and their connections (lines 1-10 in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Running-RCAT-2BBSPN"

\end_inset

).
 This is then run using the API function 
\family typewriter
RCATscriptForSPN
\family default
 which takes the list of building blocks and their connections as the two
 arguments as shown in line 12 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Running-RCAT-2BBSPN"

\end_inset

.
 It might be worth noting that the M/M/1 queue is simply a BB with one place.
 Thus the application of RCAT to SPNs is a true generalisation.
\end_layout

\begin_layout Subsection
Parsing user input
\end_layout

\begin_layout Subsubsection
Parsing Building Block String
\end_layout

\begin_layout Standard
We started with writing a parser for converting the user input of the list
 of building blocks into a MATLAB 
\emph on
struct 
\emph default
to match the formalism outlined in section 4.2.1.1.
 This is achieved in the function 
\family typewriter
createBbStruct
\family default
 which takes the list of building block strings as input and returns a 
\emph on
struct
\emph default
 (as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Building-Block-formalism"

\end_inset

) as output.
 We use regular expressions for the majority of the parsing in the function
 
\family typewriter
parseBB
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

match = regexp( bbString, ...
\end_layout

\begin_layout Plain Layout

		`{(.+)}, {(.+)}, {(.+)}, {(.+)}, {(.+)}', `tokens' );     
\end_layout

\begin_layout Plain Layout

matches = match{1};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

places = regexp( matches{1}, `
\backslash
s*,
\backslash
s*', `split' );
\end_layout

\begin_layout Plain Layout

         
\end_layout

\begin_layout Plain Layout

inputKeyset = regexp( matches{2}, `
\backslash
s*,
\backslash
s*', `split' );
\end_layout

\begin_layout Plain Layout

rateStrings = regexp( matches{3}, `
\backslash
s*,
\backslash
s*', `split' );
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

i_rates = relabelPassiveRates( inputKeyset, rateStrings );
\end_layout

\begin_layout Plain Layout

inputValues = convertToSymbolicRates( i_rates );
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

inputs = containers.Map( inputKeyset, inputValues ); 
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Parsing building block String
\begin_inset CommandInset label
LatexCommand label
name "fig:Parsing-building-block"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Parsing-building-block"

\end_inset

 gives a code snippet for parsing a building block string.
 Lines 1-2 take a building block string of the form `{P1, P2, P3}, {i_t12,
 i_t23, i_t3}, {lambda12, infinity, lambda3}, {o_t12, o_t23, o_t3}, {mu12,
 mu23, mu3}
\emph on
'
\emph default
 and divide it into five different sections; from these sections we derive
 information about the places and transitions of the building block.
 MATLAB function 
\family typewriter
regexp
\family default
 on lines 1-2 is used to match any text in parentheses using regular expression
 
\begin_inset Formula $`\{(.+)\}'$
\end_inset

.
 It is important to note that the building block must be specified as stated
 in section 4.2.1.3 else the parsing will fail.
\end_layout

\begin_layout Standard
On dividing the string into different sections, we then go on to extract
 values for the set of building block places in line 5.
 Here the MATLAB function 
\family typewriter
regexp
\family default
 splits string 
\emph on
`P1, P2, P3
\emph default
' into three substrings `P1', `P2', `P3'.
 Lines 7-8 perform the same type of split on the set of input transition
 names and input transition rates.
\end_layout

\begin_layout Standard
Transition rates which are passive are relabelled to a symbolic variable
 
\emph on
`x'
\emph default
 postfixed with the transition name of that passive rate.
 This is performed in the function 
\family typewriter
relabelPassiveRates
\family default
 as shown on line 10 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Parsing-building-block"

\end_inset

.
 Input transition rates need to be converted into MATLAB symbolic expressions
 which is achieved by the function 
\family typewriter
convertToSymbolicRates
\family default
, which used the function 
\family typewriter
stringToMatlabExpr
\family default
 (a helper function used for converting strings to MATLAB symbolic expressions).
 
\end_layout

\begin_layout Standard
We finally generate 
\emph on
inputs,
\emph default
 a field of the building block 
\emph on
struct
\emph default
, as a map of the transition names as keys and their rates as values (as
 shown on line 14 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Parsing-building-block"

\end_inset

).
 The strings of output transitions and rates are parsed similarly to create
 
\emph on
outputs
\emph default
, the last field of the building block 
\emph on
struct
\emph default
 shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Building-Block-formalism"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Parsing Building Block connections
\end_layout

\begin_layout Standard
On constructing a building block 
\emph on
struct
\emph default
, the next step is to parse the building block connection string.
 This is performed by function 
\family typewriter
parseConnections
\family default
 which takes a connections string as input and returns a map of connections
 as output.
 The map of connections has the destination as the key and the list of inputs
 as values.
 For instance, for connection 
\emph on
`o_t5 = 1 to i_t23'
\emph default
, the key will be i_t23 and the value will be the tuple (o_t5,1).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Parsing-building-block-connections"

\end_inset

 is a code snippet of the 
\family typewriter
parseConnections
\family default
 function.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

match = regexp( connectionString, `
\backslash
s*;
\backslash
s*', `split' );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for i = 1:length( match )            
\end_layout

\begin_layout Plain Layout

	matches = regexp( match{i}, `{(.+) to (.+)}', `tokens' );
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Parsing building block connections
\begin_inset CommandInset label
LatexCommand label
name "fig:Parsing-building-block-connections"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Parsing is done using regular expression; line 1 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Parsing-building-block-connections"

\end_inset

 shows how the string of connections is split into individual sub-strings
 of connections each of which are then parsed using a loop.
 The regular expression 
\begin_inset Formula $`\{(.+)\mbox{ }to\mbox{ }(.+)\}'$
\end_inset

 retrieves text from either side of `to'.
 Thus we separate the key and value pairs for our map of connections.
 
\end_layout

\begin_layout Standard
In the function 
\family typewriter
parseInputs
\family default
, each input value of type `
\emph on
o_t5 = 1
\emph default
' is parsed and is separated into transition name string `o_t5' and MATLAB
 symbolic expression `1'.
 The function returns a list of such input transitions names and probability
 tuples, which is then allocated as the value to its corresponding key in
 the connection map.
 Again since we are using regular expressions, the connections string has
 to be specified as mentioned in section 4.2.1 else the program will terminate
 because of a parsing error.
\end_layout

\begin_layout Subsection
Generating Rate Equations
\end_layout

\begin_layout Standard
To decide if a composition of building blocks has a product-form, we need
 to find the unknown (i.e.
 passive) rates to the input transitions.
 This is done by setting each unknown rate is to the reversed rate of the
 corresponding output transition.
 The system of equations thus generated are the rate equations desired.
 
\end_layout

\begin_layout Standard
This calculation is performed in the function 
\family typewriter
calculatePassiveRatesForBBs
\family default
 where for each unknown rate, we derive a rate equation by using the function
 
\family typewriter
getRateEquations
\family default
.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Generating-rate-equations-spns"

\end_inset

 is a code snippet of 
\family typewriter
getRateEquations
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

for i = 1:length( connectorList )      
\end_layout

\begin_layout Plain Layout

	map = connectorList{i};         
\end_layout

\begin_layout Plain Layout

	label = map.keys;                
\end_layout

\begin_layout Plain Layout

	passiveActionRate =  passiveActionRate + ...
\end_layout

\begin_layout Plain Layout

	getReversedRateForBB(bbStruct, label{1}) * map(label{1}); 
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Generating rate equations
\begin_inset CommandInset label
LatexCommand label
name "fig:Generating-rate-equations-spns"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To find the passive rate of the input transition we use the connections
 map generated while parsing.
 The connections map has the name of the input transition with unknown rate
 as the key and a list of `connectors' as the value.
 This list is input to the 
\family typewriter
getRateEquations
\family default
 function.
 Each connection is stored as a map with the corresponding output transition
 name as the key and its routing probability as the value.
 We retrieve this key in line 3 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Generating-rate-equations-spns"

\end_inset

.
 and find the reversed rate of the corresponding output transition using
 function 
\family typewriter
getReversedRateForBB
\family default
.
 We then multiply this with the routing probability - 
\family typewriter
map( label{1} )
\family default
 - as shown in line 5 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Generating-rate-equations-spns"

\end_inset

.
\end_layout

\begin_layout Standard
A code snippet of function 
\family typewriter
getReversedRateForBB
\family default
 is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Finding-revRate-bb-output-trans"

\end_inset

.
 To find the reversed rate of a transition we use the building block corollary
 2.6.2 stated in section 2.6.3.2 - `The reversed rate of transition 
\begin_inset Formula $T_{y}$
\end_inset

' is 
\begin_inset Formula $\lambda_{y}$
\end_inset

, i.e.
 the rate of the corresponding input transition'.
 The corresponding input transition is identified by using regular expressions
 and prefixing the transition name with `i' as described in line 1 and 3
 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Finding-revRate-bb-output-trans"

\end_inset

.
 Thus an output transition of the form `o_t23' gives an input transition
 label `i_t23'.
 The rate of this input transition is calculated by iterating over the building
 block 
\emph on
struct
\emph default
 in function 
\family typewriter
getActionRateForSPNs
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

matches = regexp( actionLabel, `
\backslash
s*_
\backslash
s*', `split' );
\end_layout

\begin_layout Plain Layout

assert( strcmp( matches(1), `o' ) )
\end_layout

\begin_layout Plain Layout

inputActionLabel = strcat( `i', `_', matches{2} );
\end_layout

\begin_layout Plain Layout

revRate = getActionRateForSPNs(inputActionLabel , bbStruct);
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Finding reversed rate of corresponding output transition
\begin_inset CommandInset label
LatexCommand label
name "fig:Finding-revRate-bb-output-trans"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a final step in generating rate equations, we print the generated equations
 on standard output which can be solved easily by the user using standard
 MATLAB tools.
\end_layout

\begin_layout Subsection
Checking Building Block conditions
\end_layout

\begin_layout Standard
For an arbitrary building block to have a product form, conditions detailed
 in Theorem 2.6.3 need to be satisfied.
 These conditions are generated and checked in function 
\family typewriter
checkBBconditions
\family default
.
 The process of validating the conditions is divided into two parts:
\end_layout

\begin_layout Enumerate
If the number of input and output transitions (i.e.
 
\begin_inset Formula $size(T_{I})\mbox{ and }size(T_{O})$
\end_inset

) is less than or equal to the number of places in the building block, we
 know the conditions are unconditionally satisfied.
 This follows directly from the nature of the system of equations generated
 by the conditions detailed in Theorem 2.6.3.
 Code for this check is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Check-BB-conditions"

\end_inset

.
 We loop over all the building blocks the SPN is composed of and also ensure
 their input and output transitions are equal as shown in line 1-3.
\end_layout

\begin_layout Enumerate
If the number of input and output transitions exceeds the number of places
 in the building block, then we generate the additional conditions required
 from Theorem 2.6.3.
 The Function 
\family typewriter
furtherConditionCheck
\family default
 generates and displays the conditions to be satisfied.
 It is important to note that these conditions need to be solved along with
 the rate equations and if they are compatible then a product form solution
 will exist.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

for i = 1:length( bbStruct )
\end_layout

\begin_layout Plain Layout

	assert( length(bbStruct(i).outputs) == 
\end_layout

\begin_layout Plain Layout

	        length(bbStruct(i).inputs) );
\end_layout

\begin_layout Plain Layout

	if ~( length(bbStruct(i).places) >= 
\end_layout

\begin_layout Plain Layout

	      length(bbStruct(i).inputs) )
\end_layout

\begin_layout Plain Layout

		furtherConditionCheck( bbStruct(i) )
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Check Building Block Conditions
\begin_inset CommandInset label
LatexCommand label
name "fig:Check-BB-conditions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generating Product Form Solution
\end_layout

\begin_layout Standard
A system of rate equations has been derived for a given SPN using the method
 in section 4.2.3, where each unknown rate is set to the reversed rate of
 the corresponding output transition.
 Theorem 2.6.3 gives conditions for a BB to have a product form which are
 derived by the aforementioned method in section 4.2.4.
 To find a product form for the given SPN, the system of equations is solved
 and if a solution exists then it is checked for compatibility with the
 product-form conditions of each BB.
 If compatible, the SPN has a product-form.
\end_layout

\begin_layout Standard
As mentioned in section 3.2.5, MATLAB functions 
\family typewriter
solve
\family default
 and 
\family typewriter
simplify
\family default
 can be used to evaluate solutions to the system of rate equations and condition
s generated.
 The process of evaluating the rate equations remains the same as section
 3.2.5.
 On finding a solution, the product form results of all the participating
 BBs is combined to give one result.
 So for a SPN with 
\begin_inset Formula $N$
\end_inset

 places the product form result will be:
\begin_inset Formula 
\[
\pi(m_{1},\mbox{ . . . , }m_{N})\propto\prod_{i=1}^{N}\rho_{i}^{m_{i}}
\]

\end_inset

where 
\begin_inset Formula $\rho_{i}$
\end_inset

 is recalculated substituting the unknowns with solutions to the system
 of rate equations.
\end_layout

\begin_layout Section
Chains of interactions between queues
\end_layout

\begin_layout Standard
This section provides a background on finding product form solutions for
 chains of interactions between queues.
 `Product-forms in multi-way synchronisations' 
\begin_inset CommandInset citation
LatexCommand cite
key "Chains"

\end_inset

 is a paper which provides the detailed theory about the concepts and algorithm
 discussed here.
 Due to time constrains, an implementation of generating product forms for
 chains of interactions could not be achieved, but we include a high level
 analysis of how it can be done by extending the current implementation
 of RCAT.
\end_layout

\begin_layout Subsection
Background
\end_layout

\begin_layout Standard
The paper 
\begin_inset CommandInset citation
LatexCommand cite
key "Chains"

\end_inset

 talks about chains of interactions between queues; for example, negative
 customers can move a customer from a non-empty queue to another queue chosen
 probabilistically thus triggering two (or more) queues (or constituent
 processes) to change their states simultaneously, causing 
\emph on
chains
\emph default
 of instantaneous state changes.
 The paper explains how such synchronisations can be modelled as the Propagation
 of Instantaneous Transitions (PITs) 
\begin_inset CommandInset citation
LatexCommand cite
key "Chains"

\end_inset

 to specify the composed models as successive pairwise synchronisations
 and thus derive product forms by an iterative application of RCAT.
\end_layout

\begin_layout Subsubsection
PEPA formalism and generating rate equations
\end_layout

\begin_layout Standard
The paper 
\begin_inset CommandInset citation
LatexCommand cite
key "Chains"

\end_inset

 introduces a new PEPA construction for representing PITs as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
P=(a\to b,\top).Q\label{eq:PepaFormalismPIT}
\end{equation}

\end_inset

The equation denotes a passive action with type 
\begin_inset Formula $a$
\end_inset

 that takes process P to Q and instantaneously synchronises to active on
 type 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\begin_layout Standard
Deriving rate equations for the instantaneously synchronising types is difficult
 and thus an algorithm has been established in the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "Chains"

\end_inset

 to perform rate equation generation with ease.
 The Algorithm is recursive in nature and considers each synchronising type
 
\begin_inset Formula $a$
\end_inset

, removes its synchronisation from the model by replacing it by type 
\begin_inset Formula $\tau$
\end_inset

 in the passive component with the corresponding reversed rate.
 It simultaneously generates the rate equations corresponding to 
\begin_inset Formula $x_{a}$
\end_inset

.
 It returns the set of rate equations for all cooperating passive actions
 on termination.
\end_layout

\begin_layout Subsection
Design and analysis for implementation
\end_layout

\begin_layout Standard
In our approach to implement RCAT for PITs, we divided the task into two
 parts - Parsing the PEPA descriptions and deriving rate equations.
 While we have not been able to implement this extension, the ideas for
 designing the implementation have been documented in the following sections.
 Due to the complexity, the design view will be clearer by using an example
 
\begin_inset CommandInset citation
LatexCommand cite
key "Chains"

\end_inset

.
 Let us take a G-network with a negative customer trigger as shown in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:G-network-chains"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/GQueueChains.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
G-network with a negative customer trigger
\begin_inset CommandInset label
LatexCommand label
name "fig:G-network-chains"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this network, we have queues 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 having exponential service times with parameters 
\begin_inset Formula $\mu_{1}$
\end_inset

 and 
\begin_inset Formula $\mu_{2}$
\end_inset

 respectively and external positive arrivals to process 
\begin_inset Formula $P$
\end_inset

 with rate 
\begin_inset Formula $\lambda$
\end_inset

.
 PITs are started in 
\begin_inset Formula $P$
\end_inset

 with a negative customer trigger with rate 
\begin_inset Formula $\beta$
\end_inset

 which propagates to 
\begin_inset Formula $Q$
\end_inset

 and so on until either queue is empty on arrival of the PIT.
\end_layout

\begin_layout Subsubsection
Parsing user input
\end_layout

\begin_layout Standard
The G-network from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:G-network-chains"

\end_inset

 is represented in PEPA using the formalism 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:PepaFormalismPIT"

\end_inset

 for representing PITs as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
P_{n}= & (\tau,\lambda).P_{n+1} & (n\geq0)\\
P_{n}= & (a_{12}^{+},\mu_{1}).P_{n-1} & (n>0)\\
P_{n}= & (a_{12}^{-},\beta).P_{n-1} & (n>0)\\
P_{n}= & (a_{21}^{-}\to a_{12}^{-},\top).P_{n-1} & (n>0)\\
P_{0}= & (a_{21}^{-},\top).P_{0}\\
\\
Q_{n}= & (a_{12}^{+},\top).Q_{n+1} & (n\geq0)\\
Q_{n}= & (\tau,\mu_{2}).Q_{n-1} & (n>0)\\
Q_{n}= & (a_{12}^{-}\to a_{21}^{-},\top).Q_{n-1} & (n>0)\\
Q_{0}= & (a_{12}^{-},\top).Q_{0}\\
\\
 & P_{0}\sync{a_{12}^{+},a_{12}^{-},a_{21}^{-}}Q_{0}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
From the PEPA description we can see that the only addition to the current
 PEPA in the MATLAB parser would be parsing expressions of the type 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:PepaFormalismPIT"

\end_inset

.
 We can extend the current parser to store action types 
\begin_inset Formula $a_{21}^{-}\to a_{12}^{-}$
\end_inset

 with their rates as symbolic variables similar to any other action type.
 As the algorithm requires the PITs to be distinguished from normal action
 types, we aim to create a map of all action types 
\begin_inset Formula $a\to b$
\end_inset

 where 
\begin_inset Formula $a$
\end_inset

 is the key and 
\begin_inset Formula $b$
\end_inset

 is the value.
 We add an extra field to our process structure 
\begin_inset Formula $R_{k}$
\end_inset

 to store these actions separately making iterating over them easy.
 
\end_layout

\begin_layout Standard
Actions of type 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:PepaFormalismPIT"

\end_inset

 always have a passive action rate specified as input as `infinity'.
 Our current PEPA parser performs relabelling of such rates to avoid confusion
 while deriving rate equations.
 To relabel rates of PITs we use the same implementation but instead of
 relabelling the rate of action type 
\begin_inset Formula $a\to b$
\end_inset

 to 
\begin_inset Formula $x_{a\to b}$
\end_inset

 we relabel it as 
\begin_inset Formula $x_{a}$
\end_inset

.
 This can easily be done by using regular expressions on action types 
\begin_inset Formula $a\to b$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Deriving rate equations
\end_layout

\begin_layout Standard
On parsing the PEPA input and generating process structure 
\begin_inset Formula $R_{k}$
\end_inset

 as a MATLAB 
\emph on
struct
\emph default
, we implement the algorithm given in to derive rate equations.
 The algorithm has an empty set of rate equations initially.
 It starts by iteration over cooplabels, i.e.
 synchronising actions, and derives rate equations for each using the rate
 equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:GenericAlgoRRCal"

\end_inset

.
 The algorithm needs to be implemented as a separate MATLAB function and
 needs to be used instead of the current reversed rate calculator to derive
 rate equations.
 The complexity of the algorithm lies in the activity substitution which
 it performs at each step for all action types.
 We can use the map of PIT action types generated in the parsing stage to
 aid with the activity substitution.
\end_layout

\begin_layout Standard
In the next chapter, we evaluate the usefulness and correctness of the implement
ed RCAT, MARCAT and RCAT for Stochastic Petri Nets.
\end_layout

\begin_layout Chapter
Evaluation
\end_layout

\begin_layout Standard
In this chapter, the implementation of RCAT is tested over several queuing
 networks and Stochastic Petri Nets and their results are verified using
 research papers and by hand.
\end_layout

\begin_layout Section
Tandem Queues
\end_layout

\begin_layout Standard
An example of a simple queuing network is a network with two queues (nodes)
 in tandem (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Tandem-Queues-Eval"

\end_inset

) with Poisson arrivals to queue one at the rate 
\begin_inset Formula $\lambda$
\end_inset

.
 Customers proceed immediately to queue 2 and depart the system on leaving
 queue 2.
 Both queues have exponential service times with parameters 
\begin_inset Formula $\mu_{1}$
\end_inset

 and 
\begin_inset Formula $\mu_{2}$
\end_inset

 respectively.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/tandemMM2Network.svg
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Tandem Queue with two Queues
\begin_inset CommandInset label
LatexCommand label
name "fig:Tandem-Queues-Eval"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This network can be described in PEPA as follows and in as MATLAB code in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PEPA-Process-Simple-Desc"

\end_inset

.
 
\begin_inset Formula 
\begin{eqnarray*}
\\
P_{n}= & (e,\lambda).P_{n+1} & (n\geq0)\\
P_{n}= & (a,\mu_{1}).P_{n-1} & (n>0)\\
Q_{n}= & (a,\top).Q_{n+1} & (n\geq0)\\
Q_{n}= & (d,\mu_{2}).Q_{n-1} & (n>0)\\
 & P_{0}\sync{a}Q_{0}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Running 
\family typewriter
RCATscript
\family default
 on this queuing network we get reversed rates as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Passive-rates-TandemQ"

\end_inset

.
 From the cooperation, it is clear that the three RCAT conditions are satisfied
 on this network.
 The program checks this and displays a message for satisfying all conditions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

Reversed rate for passive action a: x_a = lambda
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Passive rates in 
\begin_inset Formula $R_{k}$
\end_inset

 in Two node Tandem Queuing network
\begin_inset CommandInset label
LatexCommand label
name "fig:Passive-rates-TandemQ"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Paper 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

 confirms the correctness of the solution generated.
\end_layout

\begin_layout Section
Feedback Queues
\end_layout

\begin_layout Standard
We now consider an example of a generally connected pair of queues with
 feedback from the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

.
 The network has two queues, with 
\begin_inset Formula $\lambda_{1}$
\end_inset

 and 
\begin_inset Formula $\lambda_{2}$
\end_inset

 as respective external arrivals and 
\begin_inset Formula $\mu_{1}\mbox{ and }\mu_{2}$
\end_inset

 as respective service rates.
 The network has routing probability 
\begin_inset Formula $p_{12}$
\end_inset

 from queue 1 to queue 2 and 
\begin_inset Formula $p_{21}$
\end_inset

 from queue 2 to queue 1.
 Customers leave the network with probabilities 
\begin_inset Formula $1-p_{12}\mbox{ and }1-p_{21}$
\end_inset

 as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:feedbackQs"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Change diagram
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/GeneralTandem2Network.svg
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
General Tandem-2 Network
\begin_inset CommandInset label
LatexCommand label
name "fig:feedbackQs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The network is represented in MATLAB code as given in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MATLAB-input-feedbackQ"

\end_inset

 where the last line denotes the cooperation between the two queues.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

P(n) = (e1, lambda1).P(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P(n) = (a1, infinity).P(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P(n) = (d1, (1-p12)*mu1).P(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P(n) = (a2, p12*mu1).P(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

Q(n) = (e2, lambda2).Q(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

Q(n) = (a2, infinity).Q(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

Q(n) = (d2, (1-p21)*mu2).Q(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

Q(n) = (a1, p21*mu2).Q(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

P(0) with Q(0) over {a1, a2}
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
MATLAB Code for General Tandem-2 Network
\begin_inset CommandInset label
LatexCommand label
name "fig:MATLAB-input-feedbackQ"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
On parsing the input, the program produces the structure 
\begin_inset Formula $R_{k}$
\end_inset

, where 
\begin_inset Formula $R_{1}$
\end_inset

 (or process 
\begin_inset Formula $P$
\end_inset

) is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:R1-feedbackQ"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

>> r(1)
\end_layout

\begin_layout Plain Layout

definitions: 
\end_layout

\begin_layout Plain Layout

{[5x1 containers.Map]  [5x1 containers.Map]  
\end_layout

\begin_layout Plain Layout

[5x1 containers.Map]  [5x1 containers.Map]}
\end_layout

\begin_layout Plain Layout

activeLabels: {'a2'  'd1'  'e1'}
\end_layout

\begin_layout Plain Layout

passiveLabels: {'a1'}
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Formula $R_{1}$
\end_inset

 for General Tandem-2 Network
\begin_inset CommandInset label
LatexCommand label
name "fig:R1-feedbackQ"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As input in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MATLAB-input-feedbackQ"

\end_inset

, the process 
\begin_inset Formula $P$
\end_inset

 has four definitions, three active actions - 
\begin_inset Formula $\{a2,d1,e1\}$
\end_inset

 and one passive action - 
\begin_inset Formula $\{a1\}$
\end_inset

.
 Each description of the process is stored as a map with process descriptors
 as keys.
 Running the reversed rate calculation, we get solutions as shown in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Passive-rates-feedbackQ"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

Reversed rate for passive action a1: 
\end_layout

\begin_layout Plain Layout

x_a1 = p21*(lambda2 + x_a2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action a2: 
\end_layout

\begin_layout Plain Layout

x_a2 = p12*(lambda1 + x_a1)
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Passive rates for General Tandem-2 Network
\begin_inset CommandInset label
LatexCommand label
name "fig:Passive-rates-feedbackQ"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Comparing the rates with the ones in the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperTBTinMAP2003"

\end_inset

, we verify that they are as expected.
 As with the first example, we know that all the three conditions of RCAT
 are satisfied and this is verified by the program.
\end_layout

\begin_layout Section
G-Networks
\end_layout

\begin_layout Standard
G-Networks as detailed in section 2.5.3, are queuing networks with negative
 customers.
 A G-network node has two customers - positive which behave as standard
 customers in an M/M/1 queue, and negative which are Poisson arrivals that
 remove, or kill, customers in the queue when it is not empty.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/G-queue.svg
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A G-Queue j within a network
\begin_inset CommandInset label
LatexCommand label
name "fig:A-G-Queue-eval"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider a G-network with two nodes (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-G-Queue-eval"

\end_inset

), with respective positive/ negative external arrival rates 
\begin_inset Formula $\lambda_{1},\lambda_{2}$
\end_inset

/ 
\begin_inset Formula $\Lambda_{1},\Lambda_{2}$
\end_inset

 (corresponding to 
\emph on

\begin_inset Formula $\lambda$
\end_inset

 
\emph default
and 
\emph on

\begin_inset Formula $\Lambda$
\end_inset


\emph default
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MATLAB-input-gNetwork"

\end_inset

), with respective service rates 
\begin_inset Formula $\mu_{1},\mu_{2}$
\end_inset

 and with respective positive / negative routing probabilities 
\begin_inset Formula $p_{12},p_{21}$
\end_inset

 / 
\begin_inset Formula $(1-p_{12}),(1-p_{21})$
\end_inset

.
 This network is represented in MATLAB code as given in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MATLAB-input-gNetwork"

\end_inset

 where the last line denotes the cooperation between the two queues.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

P(n) = (e1, lambda1).P(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P(n) = (f1, bigLambda1).P(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P(n) = (a21, infinity).P(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P(n) = (b21, infinity).P(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P(n) = (b21, infinity).P(n) for n = 0
\end_layout

\begin_layout Plain Layout

P(n) = (a12, p12*mu1).P(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P(n) = (b12, (1-p12)*mu1).P(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Q(n) = (e2, lambda2).Q(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

Q(n) = (f2, bigLambda2).Q(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

Q(n) = (a12, infinity).Q(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

Q(n) = (b12, infinity).Q(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

Q(n) = (b12, infinity).Q(n) for n = 0
\end_layout

\begin_layout Plain Layout

Q(n) = (a21, p21*mu2).Q(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

Q(n) = (b21, (1-p21)*mu2).Q(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

P(0) with Q(0) over {a12, a21, b12, b21}
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
MATLAB Code for a Two Node G-Network
\begin_inset CommandInset label
LatexCommand label
name "fig:MATLAB-input-gNetwork"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the two queues in the G-network are M/M/1 queues, every node 
\begin_inset Formula $i$
\end_inset

 in isolation has a steady state probability of local state 
\begin_inset Formula $n$
\end_inset

 of 
\begin_inset Formula $\pi(n)=(1-\rho_{i})\rho_{i}^{n}$
\end_inset

 where 
\begin_inset Formula $\rho_{i}=\frac{\lambda_{i}+\sum_{k}x_{ki}}{\mu_{i}+\Lambda_{i}+\sum_{k}x'_{ki}}$
\end_inset

 and 
\begin_inset Formula $\lambda_{i}+\sum_{k}x_{ki}$
\end_inset

 and 
\begin_inset Formula $\mu_{i}+\Lambda_{i}+\sum_{k}x'_{ki}$
\end_inset

 is the arrival rate and service rate at node 
\begin_inset Formula $i$
\end_inset

 respectively.
 Since the nodes are M/M/1 queues, we can just run the reversed rate calculation
 of the implemented RCATscript which generates solutions given in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Passive-rates-gnetwork"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

Reversed rate for passive action a21: 
\end_layout

\begin_layout Plain Layout

x_a21 = (mu2*p21*(lambda2 + x_a12))/
\end_layout

\begin_layout Plain Layout

(bigLambda2 + mu2 + 2*x_b12)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action b21: 
\end_layout

\begin_layout Plain Layout

x_b21 = -(mu2*(lambda2 + x_a12)*(p21 - 1))/
\end_layout

\begin_layout Plain Layout

(bigLambda2 + mu2 + 2*x_b12)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action a12: 
\end_layout

\begin_layout Plain Layout

x_a12 = (mu1*p12*(lambda1 + x_a21))/
\end_layout

\begin_layout Plain Layout

(bigLambda1 + mu1 + 2*x_b21)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action b12: 
\end_layout

\begin_layout Plain Layout

x_b12 = -(mu1*(lambda1 + x_a21)*(p12 - 1))/
\end_layout

\begin_layout Plain Layout

(bigLambda1 + mu1 + 2*x_b21)
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Passive rates for a Two Node G-Network
\begin_inset CommandInset label
LatexCommand label
name "fig:Passive-rates-gnetwork"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The correctness of the steady state probability calculation and reversed
 rate calculation is established on comparing the results with the same
 example in paper 
\begin_inset CommandInset citation
LatexCommand cite
key "HarrisonPaperPerformanceImpact2009"

\end_inset

.
 The reversed rates as calculated in the paper are given below for reference.
\begin_inset Formula 
\begin{eqnarray*}
x_{akj} & = & \frac{p_{kj}\mu_{k}(\lambda_{k}+\sum_{j}x_{ajk})}{\mu_{k}+\Lambda_{k}+\sum_{j}x_{bjk}}\\
x_{bkj} & = & \frac{(1-p_{kj})\mu_{k}(\lambda_{k}+\sum_{j}x_{ajk})}{\mu_{k}+\Lambda_{k}+\sum_{j}x_{bjk}}
\end{eqnarray*}

\end_inset

 where 
\begin_inset Formula $x_{aij}$
\end_inset

 and 
\begin_inset Formula $x_{bij}$
\end_inset

 are the passive action rates corresponding to positive and negative internal
 arrivals respectively, 
\begin_inset Formula $a_{ij}\mbox{ and }b_{ij}$
\end_inset

.
\end_layout

\begin_layout Standard
To ensure that the RCAT first condition holds in this network, we add invisible
 transitions (line 5 and 12 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MATLAB-input-gNetwork"

\end_inset

) to ensure negative arrivals have no effect on an empty queue.
 If we were to run the RCATscript omitting lines 5 and 12 from the PEPA
 description in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MATLAB-input-gNetwork"

\end_inset

, we would get a condition violation error shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gNets-condition-violation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

Error using checkFirstRcatCondition (line 10)
\end_layout

\begin_layout Plain Layout

RCAT First Condition is violated.
 
\end_layout

\begin_layout Plain Layout

If you think this is an error, 
\end_layout

\begin_layout Plain Layout

then check the pepa description and try again.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Error in RCATscript (line 31) 
\end_layout

\begin_layout Plain Layout

checkFirstRcatCondition( r, stateSpace );
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
RCAT condition Violation for a Two Node G-Network
\begin_inset CommandInset label
LatexCommand label
name "fig:gNets-condition-violation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus we can see that the first two RCAT conditions are satisfied from the
 PEPA description.
 Since the passive actions in the reversed process do not have multiple
 transitions, we conclude that the third condition of RCAT holds for this
 network.
 As with previous examples, all the three conditions of RCAT are satisfied
 by the program and notified to the user.
\end_layout

\begin_layout Section
Three Node Jackson Network 
\end_layout

\begin_layout Standard
This example is taken from paper 
\begin_inset CommandInset citation
LatexCommand cite
key "marcat2003"

\end_inset

.
 Consider a three queue Jackson network, with external arrival rates 
\begin_inset Formula $\lambda_{1},\lambda_{2},\lambda_{3}$
\end_inset

 and service rates 
\begin_inset Formula $\mu_{1},\mu_{2},\mu_{3}$
\end_inset

 respectively, routing probability 
\begin_inset Formula $p_{ij}$
\end_inset

 from queue 
\begin_inset Formula $i$
\end_inset

 to queue 
\begin_inset Formula $j$
\end_inset

, 
\begin_inset Formula $i,j\in\{1,2,3\}$
\end_inset

 and where customers leave the network from node 
\begin_inset Formula $i$
\end_inset

 with probability 
\begin_inset Formula $1−\sum_{j\neq i}p_{ij}$
\end_inset

.
 This network is represented in MATLAB code as given in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MATLAB-input-3node-network"

\end_inset

 where the last two lines denote the cooperation between the two queues.
 The three queues given as input are 
\begin_inset Formula $P1,P2,P3$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

P1(n) = (e1, lambda1).P1(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P1(n) = (a21, infinity).P1(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P1(n) = (a31, infinity).P1(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P1(n) = (d1, (1-(p12+p13))*mu1).P1(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P1(n) = (a12, p12*mu1).P1(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P1(n) = (a13, p13*mu1).P1(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

P2(n) = (e2, lambda2).P2(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P2(n) = (a12, infinity).P2(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P2(n) = (a32, infinity).P2(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P2(n) = (d2, (1-(p21+p23))*mu2).P2(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P2(n) = (a21, p21*mu2).P2(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P2(n) = (a23, p23*mu2).P2(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

P3(n) = (e3, lambda3).P3(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P3(n) = (a13, infinity).P3(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P3(n) = (a23, infinity).P3(n+1) for n >= 0
\end_layout

\begin_layout Plain Layout

P3(n) = (d3, (1-(p31+p32))*mu3).P3(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P3(n) = (a31, p31*mu3).P3(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

P3(n) = (a32, p32*mu3).P3(n-1) for n > 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

P1(0) with P2(0) with P3(0) over 
\end_layout

\begin_layout Plain Layout

{a21, a31, a12, a32, a13, a23}
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
MATLAB Code for Three Node Jackson Network
\begin_inset CommandInset label
LatexCommand label
name "fig:MATLAB-input-3node-network"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The process for running RCAT on a system model for 
\begin_inset Formula $k>2$
\end_inset

 (that is for multiple agents) is the same as running RCAT on only two compound
 agents.
 We represent the multiple processes cooperating with keyword `with' and
 represent the actions the processes are cooperating on in parentheses (see
 last two lines of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MATLAB-input-3node-network"

\end_inset

).
\end_layout

\begin_layout Standard
On parsing the input, the program produces the structure 
\begin_inset Formula $R_{k}$
\end_inset

 with three nodes as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-rk-3node-network"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

r = 1x3 struct array with fields:
\end_layout

\begin_layout Plain Layout

    	definitions
\end_layout

\begin_layout Plain Layout

    	activeLabels
\end_layout

\begin_layout Plain Layout

    	passiveLabels
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Formula $R_{k}$
\end_inset

 for Three Node Jackson Network
\begin_inset CommandInset label
LatexCommand label
name "fig:-rk-3node-network"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running the reversed rate calculation, we get solutions as shown in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Passive-rates-3node-net"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

Reversed rate for passive action a21: x_a21 = 
\end_layout

\begin_layout Plain Layout

p21*(lambda2 + x_a12 + x_a32)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action a31: x_a31 = 
\end_layout

\begin_layout Plain Layout

p31*(lambda3 + x_a13 + x_a23)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action a12: x_a12 = 
\end_layout

\begin_layout Plain Layout

p12*(lambda1 + x_a21 + x_a31)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action a32: x_a32 = 
\end_layout

\begin_layout Plain Layout

p32*(lambda3 + x_a13 + x_a23)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action a13: x_a13 = 
\end_layout

\begin_layout Plain Layout

p13*(lambda1 + x_a21 + x_a31)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Reversed rate for passive action a23: x_a23 = 
\end_layout

\begin_layout Plain Layout

p23*(lambda2 + x_a12 + x_a32)
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Passive rates for Three Node Jackson Network
\begin_inset CommandInset label
LatexCommand label
name "fig:Passive-rates-3node-net"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Comparing the rates with the ones in the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "marcat2003"

\end_inset

, we verify that they are as expected.
 As with all the previous examples, we know that all the three conditions
 of RCAT are satisfied and this is verified by the program.
\end_layout

\begin_layout Section
Stochastic Petri Nets
\end_layout

\begin_layout Standard
All examples of Stochastic Petri nets (SPNs) used for testing are taken
 from the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "SPNs"

\end_inset

.
 The results in that paper have been derived by hand.
 We look at two SPNs for evaluation, one with two BBs and one with three
 BBs; thus showing that the implementation can find a product form for an
 SPN with several BBs.
\end_layout

\begin_layout Subsection
Simple SPN composed of two building blocks
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simpleSPN2BBs"

\end_inset

 gives an example of a simple SPN with two building blocks (BBs) with dotted
 lines showing synchronising transitions.
 It is specified as input in MATLAB as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Running-RCAT-2BBSPN"

\end_inset

.
 On running 
\family typewriter
RCATscriptForSPN
\family default
 on the SPN, a BB structure is created as expected with two BBs as shown
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Building-Block-Structure-eval"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

1x2 struct array with fields:     
\end_layout

\begin_layout Plain Layout

	places    
\end_layout

\begin_layout Plain Layout

	inputs     
\end_layout

\begin_layout Plain Layout

	outputs
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Building Block Structure
\begin_inset CommandInset label
LatexCommand label
name "fig:Building-Block-Structure-eval"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The program then generates rate equations and product form conditions as
 shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rate-equations-simple-spn"

\end_inset

 lines 1-3 and lines 5-10 respectively.
 These are verified by the results in the paper : 
\begin_inset CommandInset citation
LatexCommand cite
key "SPNs"

\end_inset

.
 Observing 
\begin_inset Formula $BB_{2}$
\end_inset

 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simpleSPN2BBs"

\end_inset

 we can see that, since the number of transitions in greater than the number
 of places, 
\begin_inset Formula $BB_{2}$
\end_inset

 does require additional conditions for a product form solution.
 This is indicated by the program on line 5-6.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

Printing rate equations:
\end_layout

\begin_layout Plain Layout

Rate equation for i_t23: x_i_t23 = lambda5
\end_layout

\begin_layout Plain Layout

Rate equation for i_t45: x_i_t45 = lambda12 + x_i_t23
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Product form is subject to following 
\end_layout

\begin_layout Plain Layout

conditions being fulfilled for BB 2:
\end_layout

\begin_layout Plain Layout

rho4 = lambda4 / mu4 
\end_layout

\begin_layout Plain Layout

rho45 = x_i_t45 / mu45 
\end_layout

\begin_layout Plain Layout

rho45 = rho4 * rho5 
\end_layout

\begin_layout Plain Layout

rho5 = lambda5 / mu5
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Rate equations and conditions for product form result of SPN in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:simpleSPN2BBs"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Rate-equations-simple-spn"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Solving the equations generated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rate-equations-simple-spn"

\end_inset

, a product form result can be obtained easily.
\end_layout

\begin_layout Subsection
SPN composed of three building blocks
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SPN-with-3BBs"

\end_inset

 shows a SPN structure and its decomposed BBs.
 Thus the SPN considered is composed of three building blocks.
 We can deduce their connections based on the places in each BB.
 All input transitions of all BBs are unknown (passive); there are five
 unknown input transition rates.
 The service rates (output transition rates) for all three BBs are given
 as 
\begin_inset Formula $\chi_{i}\mbox{ ,}1\leq i\leq5$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/SPNwith3BBs.svg
	scale 41

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SPN with 3 BBs and decomposition of the SPN into BBs 1–3
\begin_inset CommandInset label
LatexCommand label
name "fig:SPN-with-3BBs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We specify the building blocks as input in MATLAB as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Running-RCAT-spn-3bbs"

\end_inset

 and run the program using function 
\family typewriter
RCATscriptForSPN
\family default
.
 We deduce the synchronising transitions by observing the structure of the
 decomposed BBs and the SPN structure.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

listOfBBs ={ 
\end_layout

\begin_layout Plain Layout

`{P1, P2}, {i_t1, i_t2, i_t3}, {infinity,infinity,infinity}, 
\end_layout

\begin_layout Plain Layout

 {o_t1, o_t2, o_t3}, {chi1, chi2, chi3}',
\end_layout

\begin_layout Plain Layout

`{P4, P5}, {i_t5, i_t6}, {infinity, infinity}, {o_t5, o_t6}, 
\end_layout

\begin_layout Plain Layout

 {chi5, chi6}',
\end_layout

\begin_layout Plain Layout

`{P3}, {i_t4}, {infinity}, {o_t4}, {chi4}' }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

connectionString = `{o_t1 = 1 to i_t4} ; {o_t3 = 1 to i_t6}; 
\end_layout

\begin_layout Plain Layout

{o_t2 = 1 to i_t5}; {o_t5 = 1 to i_t3}; {o_t6 = 1 to i_t2}; 
\end_layout

\begin_layout Plain Layout

{o_t4 = 1 to i_t1}'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> RCATscriptForSPN( listOfBBs, connectionString )
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Running RCAT on a SPN in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SPN-with-3BBs"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Running-RCAT-spn-3bbs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The program then generates rate equations and product form conditions as
 shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rate-equations-spn-3bbs"

\end_inset

, lines 1-7 and lines 9-14 respectively.
 These are verified by the results in the paper : 
\begin_inset CommandInset citation
LatexCommand cite
key "SPNs"

\end_inset

.
 Observing 
\begin_inset Formula $BB_{1}$
\end_inset

 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rate-equations-spn-3bbs"

\end_inset

 we can see that, since the number of transitions in greater than the number
 of places, 
\begin_inset Formula $BB_{1}$
\end_inset

 does require additional conditions for a product form solution.
 This is indicated by the program on line 9-10.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Matlab,numbers=left,numberstyle={\scriptsize},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

Printing rate equations:
\end_layout

\begin_layout Plain Layout

Rate equation for i_t1: x_i_t1 = x_i_t4
\end_layout

\begin_layout Plain Layout

Rate equation for i_t2: x_i_t2 = x_i_t6
\end_layout

\begin_layout Plain Layout

Rate equation for i_t3: x_i_t3 = x_i_t5
\end_layout

\begin_layout Plain Layout

Rate equation for i_t4: x_i_t4 = x_i_t1
\end_layout

\begin_layout Plain Layout

Rate equation for i_t5: x_i_t5 = x_i_t2
\end_layout

\begin_layout Plain Layout

Rate equation for i_t6: x_i_t6 = x_i_t3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Product form is subject to following 
\end_layout

\begin_layout Plain Layout

conditions being fulfilled for BB 1:
\end_layout

\begin_layout Plain Layout

rho1 = x_i_t1 / chi1 
\end_layout

\begin_layout Plain Layout

rho2 = x_i_t2 / chi2
\end_layout

\begin_layout Plain Layout

rho2 = rho1 * rho3
\end_layout

\begin_layout Plain Layout

rho3 = x_i_t3 / chi3
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.8pt"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Rate equations and conditions for product form result of SPN in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SPN-with-3BBs"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Rate-equations-spn-3bbs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Solving the equations generated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rate-equations-spn-3bbs"

\end_inset

, a product form result can be obtained easily.
\end_layout

\begin_layout Section
Strengths and Weaknesses
\end_layout

\begin_layout Standard
The strengths of the work accomplished in this project include:
\end_layout

\begin_layout Itemize
Automation of the RCAT and Multiple Agent RCAT theorem using the generic
 algorithm detailed in section 2.6.2.3.
 Due to the automation, complex queuing models with multiple synchronising
 processes can be analysed using RCAT with ease and their (new) product
 form solutions can be generated.
\end_layout

\begin_layout Itemize
Automation of product form construction for Stochastic Petri Nets (SPNs).
 Due to this automation, complex and large SPNs can be analysed with ease
 as opposed to a tedious manual process.
\end_layout

\begin_layout Itemize
Parser for agents (processes) specified in PEPA, a type of Stochastic Process
 Algebra.
 Due to the modularised code, the parser can be reused in applications,
 where processes are described using the same syntax and in any extensions
 to the RCAT.
\end_layout

\begin_layout Itemize
Parser for Stochastic Petri Nets (SPNs).
 A new formalism is introduced for SPNs and a parser has been implemented
 for the same.
\end_layout

\begin_layout Itemize
An easy command line API for product form construction of both queuing models
 and SPNs, which ensures that the user does not require in depth knowledge
 of MATLAB.
\end_layout

\begin_layout Standard
Although the majority of the project was a success, there are some limitations,
 as listed below:
\end_layout

\begin_layout Itemize
The implementation of RCAT and MARCAT in this project accommodates only
 networks composed of M/M/1 queues; so the steady state probabilities calculatio
n automated by this implementation is applicable to only M/M/1 queues which
 limits the queuing models which the software can be run over.
\end_layout

\begin_layout Itemize
The implementation of RCAT for SPNs assumes the knowledge of all Building
 Blocks (BBs) which the given SPN is composed off.
 This is a disadvantage, as if the SPN is large and complex then finding
 BBs manually can be tedious.
\end_layout

\begin_layout Itemize
We had initially planned to provide a Graphical User Interface (GUI) for
 the implementation but due to time constraints it was not realised.
 The implementation will benefit from a GUI and due to the straightforward
 API it can be easily integrated with the current implementation of RCAT.
\end_layout

\begin_layout Chapter
Conclusions
\end_layout

\begin_layout Standard
To conclude this report, we summarise our achievements in terms of what
 we have learnt and consider if we have met our objectives.
 The goal of the project was to automate the construction of product forms
 in stochastic models.
 Using MATLAB, we have built a software system which successfully implements
 the generic algorithm for RCAT and MARCAT, thus achieving automatic constructio
n of rate equations used to derive product forms for queuing models.
 We have as a part of the implementation developed a parser for queuing
 models defined in PEPA syntax.
 On correctly parsing the multiple process descriptions, the software has
 been able to generate rate equations for synchronising actions.
 The solutions of these equations are then used to to calculate the marginal
 probabilities of process nodes which are then used in product form construction
 of queuing models.
 
\end_layout

\begin_layout Standard
Furthermore, we have also automated the rate equation generation (leading
 to product form construction) for Stochastic Petri Nets (SPNs) composed
 of Building Blocks in product form.
 A formalism has been provided for BBs and SPNs and a parser has been implemente
d for the same.
 In addition to generating rate equations, we have also provided the functionali
ty to check whether the conditions of the BB are in product form.
 While this implementation requires the knowledge of all BBs which a given
 SPN is composed of to be known, it does provide a scope for adding a functional
ity where this will not be necessary.
 Both the implementations have been tested for a wide variety of queuing
 models including G-queues (queues with negative customers) and relatively
 large SPNs, as detailed in the Evaluation section.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As a part of the report we have also included a small section on how the
 software can be extended to accommodate chains of interactions of queues.
 
\end_layout

\end_inset

The software has been made with a hope to provide the first step towards
 mechanically analysing complex networks composed of both queuing models
 and SPNs and thus leading to the discovery of new product form solutions.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Subsection
Chains of interactions between queues
\end_layout

\begin_layout Standard
As mentioned in section 4.3, a new algorithm has been defined in 
\begin_inset CommandInset citation
LatexCommand cite
key "Chains"

\end_inset

 to generate a system of rate equations for PITs or Propagation of Instantaneous
 Transitions.
 Chains of instantaneous state changes are caused by models with synchronisation
s defined as propagating instantaneous signals, for example, negative customers
 can move a customer from a non-empty queue to another queue chosen probabilisti
cally thus triggering two queues (or constituent process) to change their
 states simultaneously.
 These chains are modelled as PITs to specify the composed models as pairwise
 synchronisations and thus derive product-forms by an iterative application
 of RCAT.
 Section 4.3 details how the current implementation can be extended to implement
 this functionality.
 As future work, RCAT for PITs will be extremely beneficial as it would
 extend the usefulness of the software to find rare product forms in chains
 of queues.
\end_layout

\begin_layout Subsection
Automating identifying the BBs of a SPN
\end_layout

\begin_layout Standard
As mentioned before, the current implementation of RCAT for SPNs assumes
 the knowledge of all BBs which the given SPN is explicitly composed off.
 SPNs are typically large and complex which makes manually finding BBs tedious.
 An algorithm to automate the process is detailed in the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "SPNs"

\end_inset

 and can be implemented as an extension to the current implementation.
 The algorithm can be extended to directly produce programmable input, so
 the user does not need to type out verbose BB input and will directly get
 the generated rate equations.
\end_layout

\begin_layout Subsection
M/M/1
\end_layout

\begin_layout Standard
The implementation of RCAT and MARCAT in this project accommodates only
 networks composed of M/M/1 queues; so the steady state probabilities calculatio
n automated by this implementation is applicable to only M/M/1 queues.
 The implementation would benefit greatly if this restriction were removed
 and would thus be able to analyse queuing models which go beyond M/M/1
 queues.
 As the program logic is loosely coupled, adding this functionality is possible
 without drastic changes to current implementation.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "1"
key "PerformanceModellingHarrisonBook"

\end_inset

 Harrison, Peter G.
 and Patel, Naresh M.
 
\begin_inset Quotes eld
\end_inset

Performance Modelling of Communication Networks and Computer Architectures.
\begin_inset Quotes erd
\end_inset

 Addison-Wesley, 1992.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "2"
key "MarkovChainsQueuesStewartBook"

\end_inset

 Stewart, William, J.
 
\begin_inset Quotes eld
\end_inset

Probability, Markov Chains, Queues and Simulation: The mathematical basis
 of performance modelling.
\begin_inset Quotes erd
\end_inset

 Princeton University Press, 2009.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "3"
key "HarrisonPaperTBTinMAP2003"

\end_inset

 Harrison, Peter G.
 “Turning back time in Markovian process algebra.” Theoretical Computer Science,
 vol.
 290, pp.
 1947–1986, 2003.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "4"
key "HarrisonPaperPerformanceImpact2009"

\end_inset

 Harrison, Peter G.
 “Turning Back TimeWhat Impact on Performance?.” The Computer Journal, vol.
 53, no.
 6, pp.
 860–868, 2010.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "5"
key "LectureNotes"

\end_inset

 Harrison, Peter G., Casale, Giuliano.
 and Bradley, Jeremy, T.
 “Course 436 : Performance Analysis,” Imperial College London, 2010.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "6"
key "BradleyRP&RCAT"

\end_inset

 Bradley, Jeremy, T.
 “RCAT: From PEPA to Product form.” Technical Report, vol.
 2007, Issue 2, pp.1–8, March 2007.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "7"
key "GelenbeGNetworks"

\end_inset

Gelenbe, Erol.
 “Product-Form Queueing Networks with Negative and Positive Customers.” Journal
 of Applied Probability, Vol.
 28, No.
 3, pp.
 656-663, 1991.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "8"
key "HillstonPEPAbook"

\end_inset

 Hillston, Jane.
 
\begin_inset Quotes eld
\end_inset

A Compositional Approach to Performance Modelling.
\begin_inset Quotes erd
\end_inset

 New York, NY, USA: Cambridge University Press, 1996.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "9"
key "RCAT2009Paper"

\end_inset

 Harrison, Peter G., Lladó, Catalina M.
 and Puigjaner, Ramón.
 
\begin_inset Quotes eld
\end_inset

A unified approach to modelling the performance of concurrent systems.
\begin_inset Quotes erd
\end_inset

 Simulation Modelling Practice and Theory 17 , no.
 9 (2009): 1445-1456.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "10"
key "ercat"

\end_inset

 Harrison, Peter G.
 
\begin_inset Quotes eld
\end_inset

Reversed processes, product forms and a non-product form.
\begin_inset Quotes erd
\end_inset

 Linear Algebra and Its Applications, Volume 386, pp.359–381, 2004.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "11"
key "marcat2003"

\end_inset

 Harrison, Peter G., Lee, Ting.
 
\begin_inset Quotes eld
\end_inset

Reversed Processes of Multiple Agent Cooperations.
\begin_inset Quotes erd
\end_inset

 19th UK Performance Engineering Workshop, pp.257–265, 2003.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "12"
key "marcatHarLee2005"

\end_inset

 Harrison, Peter G., Lee, Ting T.
 
\begin_inset Quotes eld
\end_inset

Separable equilibrium state probabilities via time reversal in Markovian
 process algebra.
\begin_inset Quotes erd
\end_inset

 Theoretical Computer Science, vol 346, pp.161–182, 2005
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "13"
key "SPNs"

\end_inset

 Balsamo, Simonetta., Harrison, Peter G., Marin, Andrea.
 
\begin_inset Quotes eld
\end_inset

Methodological construction of product-form stochastic Petri nets for performanc
e evaluation.
\begin_inset Quotes erd
\end_inset

 The Journal of Systems and Software 85 (2012) 1520–1539.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "14"
key "Chains"

\end_inset

 Harrison, Peter G., Marin, Andrea.
 
\begin_inset Quotes eld
\end_inset

Product-forms in multi-way synchronisations
\begin_inset Quotes erd
\end_inset

.
 The Computer Journal.
 
\end_layout

\begin_layout Chapter
\start_of_appendix
MATLAB Code for Unit Tests
\end_layout

\begin_layout Section
Unit Test for registering processes
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\sffamily},breaklines=true,language=Matlab,numbers=left,numberstyle={\tiny},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

function testRegisterProcess()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Setting up the process for testing   
\end_layout

\begin_layout Plain Layout

	syms lambda n x_a;     
\end_layout

\begin_layout Plain Layout

	registeredProcesses = containers.Map();     
\end_layout

\begin_layout Plain Layout

	activeActionLabels = containers.Map();     
\end_layout

\begin_layout Plain Layout

	passiveActionLabels = containers.Map();
\end_layout

\begin_layout Plain Layout

	registerProcess( registeredProcesses, activeActionLabels,...
         
\end_layout

\begin_layout Plain Layout

	passiveActionLabels, `P(n) = (e, lambda).P(n+1) for n >= 0' );
\end_layout

\begin_layout Plain Layout

	P = registeredProcesses( `P' );
\end_layout

\begin_layout Plain Layout

% Retrieve process registered    
\end_layout

\begin_layout Plain Layout

	P = P{1};
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

% Test if process descriptors have been parsed correctly
\end_layout

\begin_layout Plain Layout

	assertEqual( registeredProcesses.length(), 1 );
\end_layout

\begin_layout Plain Layout

	assertEqual( P( `actionName' ), `e' );      
\end_layout

\begin_layout Plain Layout

	assertEqual( P( `actionRate' ), lambda )     
\end_layout

\begin_layout Plain Layout

	assertEqual( P( `transitionFromState' ), eval(`n') );      
\end_layout

\begin_layout Plain Layout

	assertTrue( isequal( P( `transitionToState' ), n+1 ) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Test the domain function by giving it actual values 
\end_layout

\begin_layout Plain Layout

	domain = P( `domain' );     
\end_layout

\begin_layout Plain Layout

	assertTrue( isequal( 0, domain(1) ) );     
\end_layout

\begin_layout Plain Layout

	assertTrue( isequal( Inf, domain(2) ) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Add Passive process to test for parsing and relabelling rates
\end_layout

\begin_layout Plain Layout

	registerProcess( registeredProcesses, activeActionLabels,...
         
\end_layout

\begin_layout Plain Layout

	passiveActionLabels, `Q(n) = (a, infinity).Q(n+1) for n >= 0' );
\end_layout

\begin_layout Plain Layout

	assertEqual( registeredProcesses.length(), 2 );
\end_layout

\begin_layout Plain Layout

	Q = registeredProcesses( `Q' );
\end_layout

\begin_layout Plain Layout

	Q = Q{1};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Test passive rate relabelling
\end_layout

\begin_layout Plain Layout

	assertEqual( Q( `actionRate' ), x_a );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% the input has one process with active action type and one with     
\end_layout

\begin_layout Plain Layout

% passive action type.
 Thus the foll.
 assertions
\end_layout

\begin_layout Plain Layout

	assertEqual( activeActionLabels.length(), 1 );     
\end_layout

\begin_layout Plain Layout

	assertEqual( activeActionLabels(`P'), { P(`actionName') } );
\end_layout

\begin_layout Plain Layout

	assertEqual( passiveActionLabels.length(), 1 );
\end_layout

\begin_layout Plain Layout

	assertEqual( passiveActionLabels(`Q'), { Q(`actionName') } ); 
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

% Test if input validates correctly i.e.
 check exceptions thrown
\end_layout

\begin_layout Plain Layout

	assertExceptionThrown( @() registerProcess( ...
\end_layout

\begin_layout Plain Layout

	registeredProcesses, activeActionLabels,...
\end_layout

\begin_layout Plain Layout

	passiveActionLabels, `Q(n) = a, infinity)   Q(n+1)  n >= 0' ), ...
\end_layout

\begin_layout Plain Layout

	`RCATscript:InvalidInputParsedRegisterProcess' );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	assertExceptionThrown( @() registerProcess(...
\end_layout

\begin_layout Plain Layout

	registeredProcesses, activeActionLabels,...
\end_layout

\begin_layout Plain Layout

	passiveActionLabels, `' ), `RCATscript:InvalidInputRegisterProcess' );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	assertExceptionThrown( @() registerProcess(...
\end_layout

\begin_layout Plain Layout

	registeredProcesses, activeActionLabels,...
\end_layout

\begin_layout Plain Layout

	passiveActionLabels, `Q(n) = (2e, infinity).Q(n+1) for n >= 0' ),...
\end_layout

\begin_layout Plain Layout

	`RCATscript:NumericActionLabel' );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This program listing unit tests the part of the implementation to do with
 parsing.
 It checks if a PEPA process is correctly parsed using various assertions.
 The comments on the listing (lines starting with `%') provide context to
 the assertions.
 Different parts of the program have been unit tested with a similar approach.
\end_layout

\begin_layout Section
Unit test for string to expression generation
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\sffamily},breaklines=true,language=Matlab,numbers=left,numberstyle={\tiny},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

function testStringToMatlabExpr()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Declare variables symbolic for test case set up
\end_layout

\begin_layout Plain Layout

	syms lambda1 mu1 lambda_1 mu_1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Simple case
\end_layout

\begin_layout Plain Layout

	assertTrue( isequal( mu_1, stringToMatlabExpr(`mu_1') ) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Non-trivial cases, examples added with spaces in expr
\end_layout

\begin_layout Plain Layout

% which should be ignored by the function
\end_layout

\begin_layout Plain Layout

	assertTrue( isequal(( 1 - lambda1 ) * mu1, ...
\end_layout

\begin_layout Plain Layout

	stringToMatlabExpr(`(1-lambda1)*mu1') ) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	assertTrue( isequal( ( 1 - lambda1 ) * mu1, ...
\end_layout

\begin_layout Plain Layout

	stringToMatlabExpr(`( 1 - lambda1 ) * mu1') ) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	assertTrue( isequal( ( 1 - lambda_1 ) * mu_1, ...
\end_layout

\begin_layout Plain Layout

	stringToMatlabExpr(`(1-lambda_1)*mu_1') ) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Test if maths expressions are evaluated correctly
\end_layout

\begin_layout Plain Layout

	assertTrue( isequal(7404, stringToMatlabExpr(`(1234)* 6') ) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Test if wrong output is caught correctly
\end_layout

\begin_layout Plain Layout

    assertExceptionThrown( @() stringToMatlabExpr(`(1-)*mu1'), 
\end_layout

\begin_layout Plain Layout

	`RCATscript:InvalidStringToMatlabExpr' ) 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This program listing unit tests the part of the implementation to do with
 converting strings to MATLAB symbolic expressions.
 It is relatively simple and shows that the program stringToMatlabExpr has
 been tested over various inputs including an erroneous input.
\end_layout

\begin_layout Section
Running Unit Tests
\end_layout

\begin_layout Standard
The instructions below assume that the xUnit Framework has been installed
 in MATLAB and is ready to run.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\sffamily},breaklines=true,language=Matlab,numbers=left,numberstyle={\tiny},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

% go to the directory containing the tests
\end_layout

\begin_layout Plain Layout

>> cd tests/ 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% The run the undermentioned command
\end_layout

\begin_layout Plain Layout

>> runtests 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Test output looks as follows
\end_layout

\begin_layout Plain Layout

Test suite: /Users/.../Code/tests 
\end_layout

\begin_layout Plain Layout

Starting test run with test cases.
\end_layout

\begin_layout Plain Layout

.....PASSED in 11.191 seconds.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
